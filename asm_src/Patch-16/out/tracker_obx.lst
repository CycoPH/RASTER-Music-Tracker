mads 2.1.0 build 8 (23 Dec 19)
Source: rmtplayr.a65
     1 				;*
     2 				;* Raster Music Tracker, RMT Atari routine version Patch16-3.2
     3 				;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2009
     4 				;* http://raster.atari.org
     5 				;*
     6 				;* Unofficial version by VinsCool, 2021 - 2022
     7 				;* https://github.com/VinsCool/RMT-Patch16
     8 				;*
     9 				;* TO DO: A lot... So much to re-order and cleanup...
    10 				;* I must recalculate everything, once the full code cleanup and optimisation is done.
    11 				;* Currently, all infos are incorrect due to the massive amount of changes I have done into the code.
    12 				;* I apologise for the inconvenience, I am doing my best to clean everything to make sense again.
    13 				;*
    14
    15 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    16
    17 				;* RMT FEATures definitions file
    18 					icl "rmt_feat.a65"
Source: rmt_feat.a65
     1 				;*
     2 				;* RMT FEATures definitions
     3 				;*
     4 				;* For optimizations of RMT player routine to concrete RMT module only!
     5
     6 				;* ------------------------------------------------------------------------------------------------------------
     7
     8 				;* PATCH16 ADDITIONS BY VINSCOOL, USE ONLY IF YOU KNOW WHAT YOU ARE DOING!
     9
    10 				;* enable ONLY if the target output is the actual RMT driver binary (tracker.obx), There are few specific changes involved!
    11 = 0001			FEAT_IS_TRACKER 	equ 1
    12
    13 				;* Simple RMT Player is a simple recreation of the original .xex export player from RMT, enable for few bonus features
    14 = 0000			FEAT_IS_SIMPLEP 	equ 0
    15
    16 							ERT [FEAT_IS_TRACKER+FEAT_IS_SIMPLEP]=0	;* The RMT driver has no driver parameter defined!
    17 							ERT [FEAT_IS_TRACKER+FEAT_IS_SIMPLEP]=2	;* The RMT driver could not have more than 1 driver parameter defined!
    18
    19 							IFT FEAT_IS_TRACKER	;* must be defined to work around some undefined labels...
    20 = 0000			EXPORTXEX 		equ 0
    21 = 0000			EXPORTSAP		equ 0
    22 							EIF
    23
    24 				;* ------------------------------------------------------------------------------------------------------------
    25
    26 				;* STEREO MODE MUST ALWAYS BE 1 IF THE OUTPUT IS INTENDED FOR USE AS RMT DRIVER BINARY, ELSE IT WILL BE BROKEN!
    27 					
    28 							IFT FEAT_IS_TRACKER
    29 = 0001			STEREOMODE		equ 1
    30 							ELI !FEAT_IS_SIMPLEP	;* dasmplayer.asm has its own definition there so it could be ignored here 
    31 				STEREOMODE		equ 0
    32 										;* 0 => compile RMTplayer for 4 tracks mono
    33 										;* 1 => compile RMTplayer for 8 tracks stereo
    34 										;* 2 => compile RMTplayer for 4 tracks stereo L1 R2 R3 L4
    35 										;* 3 => compile RMTplayer for 4 tracks stereo L1 L2 R3 R4
    36 										;* 4 => compile RMTplayer for 8 tracks Dual Mono LR1 LR2 LR3 LR4 
    37 							EIF
    38 							
    39 				;* Stereo mode may also be defined from a different location (game/demo, dasmplayer.asm, etc), comment it out if necessary
    40
    41 				;* ------------------------------------------------------------------------------------------------------------
    42
    43 				;* --------BEGIN--------
    44
    45 = 0000			FEAT_SFX		equ 0			;* 0 => No SFX support, 1 => SFX support
    46 = 0000			FEAT_GLOBALVOLUMEFADE	equ 0			;* 0 => No RMTGLOBALVOLUMEFADE support, 1=> RMTGLOBALVOLUMEFADE support (+7 bytes)
    47 = 0000			FEAT_NOSTARTINGSONGLINE	equ 0			;* 0 => Init with starting songline, 1=> no starting songline (start from songline 0 always), cca 22 or 24 bytes
    48 = 0000			FEAT_INSTRSPEED		equ 0			;* cca 21 or 5 bytes
    49 = 0000			FEAT_CONSTANTSPEED	equ 0			;* cca 28 bytes
    50
    51 				;* ------------------------------------------------------------------------------------------------------------
    52
    53 				;* VARIOUS COMMANDS
    54 = 0001			FEAT_COMMAND1		equ 1			;* cca 8 bytes
    55 = 0001			FEAT_COMMAND2		equ 1			;* cca 20 bytes (+save 1 address in zero page) and quicker whole RMT routine
    56 = 0001			FEAT_COMMAND3		equ 1			;* cca 12 bytes
    57 = 0001			FEAT_COMMAND4		equ 1			;* cca 15 bytes
    58 = 0001			FEAT_COMMAND5		equ 1			;* cca 67 bytes
    59 = 0001			FEAT_COMMAND6		equ 1			;* cca 15 bytes
    60 = 0001			FEAT_COMMAND7		equ 1			;* patch16 addition by Vin, valid values are from $00 to $FC included 
    61
    62 				;* COMMAND7 Volume Only mode (command 7 with parameter == $FF)
    63 = 0001			FEAT_VOLUME_ONLY	equ 1			;* patch16 change by Vin, unsure how many bytes are involved
    64
    65 				;* COMMAND7 Two-Tone Filter toggle (command 7 with parameter == $FE to enable, $FD to disable) 
    66 = 0001			FEAT_TWO_TONE		equ 1			;* patch16 change by Vin, unsure how many bytes are involved
    67
    68 				;* PORTAMENTO
    69 = 0001			FEAT_PORTAMENTO		equ 1			;* cca 138 bytes and quicker whole RMT routine
    70
    71 				;* FILTER
    72 = 0001			FEAT_FILTER		equ 1			;* cca 179 bytes and quicker whole RMT routine
    73 = 0001			FEAT_FILTERG0L		equ 1			;* (cca 38 bytes for each)
    74 = 0001			FEAT_FILTERG1L		equ 1
    75 = 0001			FEAT_FILTERG0R		equ 1
    76 = 0001			FEAT_FILTERG1R		equ 1
    77
    78 				;* New 16-bit code, for full 16-bit support
    79 = 0001			FEAT_FULL_16BIT		equ 1			;* patch16 addition by Vin, unsure how many bytes are involved
    80
    81 				;* Alternative 16-bit method, which simplifies the old BASS16 method, can be used to output 16-bit frequencies using Distortion 6
    82 = 0001			FEAT_BASS16		equ 1			;* patch16 addition by Vin, unsure how many bytes are involved
    83
    84 				;* New Sawtooth code, output the Sawtooth waveform, or Triangle
    85 = 0001			FEAT_FULL_SAWTOOTH	equ 1			;* patch16 addition by Vin, unsure how many bytes are involved
    86
    87 				;* TABLE TYPE (i.e. TABLETYPE=1)
    88 = 0001			FEAT_TABLETYPE		equ 1			;* cca 53 bytes and quicker whole RMT routine
    89
    90 				;* TABLE MODE (i.e. TABLEMODE=1)
    91 = 0001			FEAT_TABLEMODE		equ 1			;* cca 16 bytes and quicker whole RMT routine
    92
    93 				;* TABLE GO (i.e. TGO is nonzero value)
    94 = 0001			FEAT_TABLEGO		equ 1			;* cca 6 bytes and quicker whole RMT routine
    95
    96 				;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting is nonzero value)
    97 = 0001			FEAT_AUDCTLMANUALSET	equ 1			;* cca 27 bytes and quicker whole RMT routine
    98
    99 				;* VOLUME MINIMUM (i.e. VMIN is nonzero value)
   100 = 0001			FEAT_VOLUMEMIN		equ 1			;* cca 12 bytes and quicker whole RMT routine
   101
   102 				;* INSTREUMENT EFFECTS (i.e. VIBRATO or FSHIFT are nonzero values with nonzero DELAY)
   103 = 0001			FEAT_EFFECTVIBRATO	equ 1			;* cca 65 bytes and quicker whole RMT routine
   104 = 0001			FEAT_EFFECTFSHIFT	equ 1			;* cca 11 bytes and quicker whole RMT routine
   105 				;* (btw - if no one from this two effect is used, it will save cca 102 bytes)
   106
   107 				;* Manual tuning table loaded from instruments, this is experimental code, do not use unless you have a reason to try it out!
   108 = 0000			FEAT_TABLE_MANUAL	equ 0			;* patch16 addition by Vin, unsure how many bytes are involved
   109
   110 				;* --------END--------
   111
    19 					
    20 				;* For optimizations of RMT player routine to concrete RMT module only!
    21
    22 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    23
    24 				;* start of RMT definitions...
    25
    26 					IFT FEAT_IS_SIMPLEP
    27 				PLAYER			equ $3100	; VUPlayer export driver 
    28 					ELS
    29 = 3400			PLAYER			equ $3400	; tracker.obx driver and everything else by default
    30 					EIF
    31
    32 					IFT STEREOMODE==1
    33 = 0008			TRACKS			equ 8
    34 					ELS
    35 				TRACKS			equ 4
    36 					EIF
    37
    38 = B000			TABLES			equ $B000	; This may be moved elsewhere if necessary 
    39
    40 = 000C			INSTRPAR		equ 12
    41
    42 				;* RMT ZeroPage addresses
    43 					org 203	     	;* org $CB
    44 					
    45 				p_tis
    46 				ptrInstrumentTbl	org *+2			; ptr to Instrument table ptrs
    47 				ptrTracksTblLo		org *+2			; ptr to low byte of track ptrs
    48 				ptrTracksTblHi		org *+2			; ptr to high byte of track ptrs
    49 				ptrSongLines		org *+2			; ptr to song data
    50 				ns					org *+2
    51 				nr					org *+2
    52 				nt					org *+2
    53 				reg1				org *+1
    54 				reg2				org *+1
    55 				reg3				org *+1
    56 				tmp					org *+1
    57
    58 					IFT FEAT_COMMAND2
    59 				frqaddcmd2			org *+1
    60 					EIF
    61 					
    62 				;* possible improvement: setting variables after the RMT driver itself? 
    63 				;* That would make adjustments easier to manage, if this works as I expect...
    64
    65 					IFT TRACKS>4			
    66 					org PLAYER-$400+$40
    67 					ELS
    68 					org PLAYER-$400+$e0
    69 					EIF
    70 					
    71 				track_variables
    72
    73 				trackn_TblLo			org *+TRACKS		; low byte of ptrs to each track's data
    74 				trackn_TblHi			org *+TRACKS		; Hi byte of ptrs to each track's data
    75 				trackn_idx				org *+TRACKS		; How far into each track
    76 				trackn_pause			org *+TRACKS		; 1 new note, 0 nothing new
    77 				trackn_note				org *+TRACKS
    78 				trackn_volume			org *+TRACKS
    79 				trackn_volumeenvelope	org *+TRACKS
    80 				trackn_command			org *+TRACKS
    81 				trackn_effectparameter	org *+TRACKS
    82 				trackn_shiftfrq			org *+TRACKS
    83
    84 					IFT FEAT_PORTAMENTO
    85 				trackn_portafrqc 	org *+TRACKS
    86 				trackn_portafrqa 	org *+TRACKS
    87 				trackn_portaspeed 	org *+TRACKS
    88 				trackn_portaspeeda 	org *+TRACKS
    89 				trackn_portadepth 	org *+TRACKS
    90 					EIF
    91 					
    92 				trackn_instrx2			org *+TRACKS		; New instrument init required (-1 = new new instrument)
    93 				trackn_instrdb			org *+TRACKS
    94 				trackn_instrhb			org *+TRACKS
    95 				trackn_instridx			org *+TRACKS
    96 				trackn_instrlen			org *+TRACKS
    97 				trackn_instrlop			org *+TRACKS
    98 				trackn_instrreachend	org *+TRACKS
    99 				trackn_volumeslidedepth org *+TRACKS
   100 				trackn_volumeslidevalue org *+TRACKS
   101
   102 					IFT FEAT_VOLUMEMIN
   103 				trackn_volumemin	org *+TRACKS
   104 					EIF
   105 					
   106 = 0001			FEAT_EFFECTS equ FEAT_EFFECTVIBRATO||FEAT_EFFECTFSHIFT
   107 					IFT FEAT_EFFECTS
   108 				trackn_effdelay		org *+TRACKS
   109 					EIF
   110 					
   111 					IFT FEAT_EFFECTVIBRATO
   112 				trackn_effvibratoa	org *+TRACKS
   113 					EIF
   114 					
   115 					IFT FEAT_EFFECTFSHIFT
   116 				trackn_effshift		org *+TRACKS
   117 					EIF
   118 					
   119 				trackn_tabletypespeed 	org *+TRACKS
   120
   121 					IFT FEAT_TABLEMODE
   122 				trackn_tablemode	org *+TRACKS
   123 					EIF
   124 					
   125 				trackn_tablenote	org *+TRACKS
   126 				trackn_tablea		org *+TRACKS
   127 				trackn_tableend		org *+TRACKS
   128
   129 					IFT FEAT_TABLEGO
   130 				trackn_tablelop		org *+TRACKS
   131 					EIF
   132 					
   133 				trackn_tablespeeda	org *+TRACKS
   134
   135 					IFT FEAT_FILTER
   136 				trackn_filter		org *+TRACKS		;* POTENTIAL OPTIMISATION: it is NOT necessary to use all tracks... only channel 1 and 2 will use it to offset the other...
   137 					EIF
   138
   139 					IFT FEAT_FULL_16BIT||FEAT_BASS16	;* EXPERIMENTAL METHOD: full 16-bit values, Sawtooth and Filter may also benefit from this approach...
   140 				trackn_bass16		org *+TRACKS
   141 					EIF
   142 					
   143 					IFT FEAT_FULL_16BIT||FEAT_BASS16||FEAT_FULL_SAWTOOTH
   144 				g_flag			org *+TRACKS
   145 					EIF
   146 					
   147 					IFT FEAT_TABLE_MANUAL
   148 				trackn_pointertable	org *+TRACKS	
   149 					EIF
   150 					
   151 					IFT FEAT_AUDCTLMANUALSET
   152 				trackn_audctl		org *+TRACKS
   153 					EIF	
   154 					
   155 				trackn_audf		org *+TRACKS
   156 				trackn_audc		org *+TRACKS
   157
   158 				v_aspeed		org *+1
   159
   160 				track_endvariables
   161
   162 				;* end of RMT definitions...
   163 					
   164 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   165
   166 				;* start of RMT data... maybe this could be moved elsewhere, much like the tuning tables?
   167 					
   168 					org PLAYER-$0200	; I need to improve the label organisation here as well, also do I really need to org there? my memory is hazy, why did even do this...?
   169 					
   170 					IFT FEAT_AUDCTLMANUALSET
   171 				AUDCTLBITS	; bits to test for AUDCTL lookup tables
   172 FFFF> 3200-3245> 80	POLY9	dta $80	; bit 7
   173 3201 40			CH1_179	dta $40	; bit 6
   174 3202 20			CH3_179	dta $20	; bit 5
   175 3203 10			JOIN_12	dta $10	; bit 4
   176 3204 08			JOIN_34	dta $08	; bit 3
   177 3205 04			HPF_CH1	dta $04	; bit 2
   178 3206 02			HPF_CH2	dta $02	; bit 1
   179 3207 01			CLOCK15	dta $01	; bit 0
   180 					EIF	
   181 					
   182 3208			TABLES_MSB
   183 = 3209			DISTORTIONS equ *+1
   184 3208 B2 00			dta >PAGE_DISTORTION_A,$00
   185 320A B0 20			dta >PAGE_DISTORTION_2,$20
   186 320C B1 40			dta >PAGE_DISTORTION_4,$40 	
   187 320E B2 A0			dta >PAGE_DISTORTION_A,$A0
   188 3210 B2 80			dta >PAGE_DISTORTION_A,$80
   189 3212 B2 A0			dta >PAGE_DISTORTION_A,$A0
   190 3214 B3 C0			dta >PAGE_DISTORTION_C,$C0
   191 3216 B4 C0			dta >PAGE_DISTORTION_E,$C0
   192 					
   193 					IFT FEAT_EFFECTVIBRATO
   194 3218			vibtabbeg 
   195 3218 00 01 05 0B				dta 0,vib1-vib0,vib2-vib0,vib3-vib0
   196 321C 00			vib0	dta 0
   197 321D 01 FF FF 01		vib1	dta 1,-1,-1,1
   198 3221 01 00 FF FF 00 01	vib2	dta 1,0,-1,-1,0,1
   199 3227 01 01 00 FF FF FF + vib3	dta 1,1,0,-1,-1,-1,-1,0,1,1
   200 3231			vibtabnext
   201 3231 00					dta vib0-vib0+0
   202 3232 02 03 04 01				dta vib1-vib0+1,vib1-vib0+2,vib1-vib0+3,vib1-vib0+0
   203 3236 06 07 08 09 0A 05			dta vib2-vib0+1,vib2-vib0+2,vib2-vib0+3,vib2-vib0+4,vib2-vib0+5,vib2-vib0+0
   204 323C 0C 0D 0E 0F 10 11 + 		dta vib3-vib0+1,vib3-vib0+2,vib3-vib0+3,vib3-vib0+4,vib3-vib0+5,vib3-vib0+6,vib3-vib0+7,vib3-vib0+8,vib3-vib0+9,vib3-vib0+0
   205 					EIF	
   206 					
   207 3246				org PLAYER-$0100	;* it may be possible to reduce this table by half the size it is... this was something I did for the older RMT Patch16 code, so the option is still valuable...
   208 3300			volumetab
   209 3300-3CDC> 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
   210 3310 00 00 00 00 00 00 + 	dta $00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
   211 3320 00 00 00 00 01 01 + 	dta $00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
   212 3330 00 00 00 01 01 01 + 	dta $00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
   213 3340 00 00 01 01 01 01 + 	dta $00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
   214 3350 00 00 01 01 01 02 + 	dta $00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
   215 3360 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
   216 3370 00 00 01 01 02 02 + 	dta $00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
   217 3380 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
   218 3390 00 01 01 02 02 03 + 	dta $00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
   219 33A0 00 01 01 02 03 03 + 	dta $00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
   220 33B0 00 01 01 02 03 04 + 	dta $00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
   221 33C0 00 01 02 02 03 04 + 	dta $00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
   222 33D0 00 01 02 03 03 04 + 	dta $00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
   223 33E0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
   224 33F0 00 01 02 03 04 05 + 	dta $00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
   225
   226 				;* end of RMT data...
   227 					
   228 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   229
   230 				;* start of RMT jump table...
   231
   232 3400			        org PLAYER			;* Possible improvement: give proper labels to each JMPs below... to avoid confusion, and also make things easier to map in memory, unless the destination is being JSR'ed directly...
   233
   234 3400			RASTERMUSICTRACKER
   235 3400 4C 0F 34			jmp rmt_init			;* Must be run first, to clear memory and initialise the player... Once this is done, run rmt_play afterwards, or Set_Pokey if you want to manually time certain things.
   236 3403 4C 12 36			jmp rmt_play			;* One play each subroutine call. SetPokey is executed first, then all the play code is ran once, until the RTS. rmt_play could be called multiple times per frame if wanted.
   237 3406 4C 33 36			jmp rmt_p3				;* Similar to rmt_play, but will also skip SetPokey and the instruments/songlines/tracklines initialisation, very useful for playing simple things.
   238 3409 4C 5C 34			jmp rmt_silence			;* Run this to stop the driver, and reset all POKEY registers to 0. This is also part of rmt_init when it is executed first.
   239 340C 4C 68 3C			jmp SetPokey			;* Run to copy the contents of the Shadow POKEY registers (v_audctl, v_skctl, trackn_audf,x etc) into the real ones. Will be run first each time rmt_play is called.
   240 					IFT FEAT_SFX
   241 					jmp rmt_sfx				;* A=note(0,..,60),X=channel(0,..,3 or 0,..,7),Y=instrument*2(0,2,4,..,126)
   242 					EIF
   243 					
   244 				;* end of RMT jump table... from here, all the main driver code is being executed, have fun playing around! ;)
   245
   246 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   247
   248 				;* start of rmt_init code...
   249 				; A = Starting song line
   250 				; X = low byte of the RMT module
   251 				; Y = hi byte of the RMT module
   252 340F			rmt_init
   253 					; (ns) -> module data
   254 340F 86 D3			stx ns
   255 3411 84 D4			sty ns+1
   256 					IFT FEAT_NOSTARTINGSONGLINE==0
   257 3413 48					pha	; backup the song line into the stack for now... I wonder if I could just use tmp in zeropage instead...
   258 					EIF
   259 					
   260 					; Clear the RMT variables
   261 					IFT track_endvariables-track_variables>255
   262 						; more than 255 bytes in variables memory...
   263 						; so clear from the front and 256 bytes from the end |>--->----|
   264 3414 A0 00				ldy #0
   265 3416 98					tya
   266 3417			ri_clear_loop	
   267 3417 99 40 30				sta track_variables,y
   268 341A 99 89 30				sta track_endvariables-$100,y
   269 341D C8					iny
   270 341E D0 F7				bne ri_clear_loop
   271 					ELS
   272 						; Clear from the back  |----<|
   273 						ldy #track_endvariables-track_variables	; How many bytes to clear
   274 						lda #0
   275 				ri_clear_loop	
   276 						sta track_variables-1,y
   277 						dey
   278 						bne ri_clear_loop
   279 					EIF
   280 					
   281 					; Parse the RMT module data
   282 					; Track length: +4
   283 3420 A0 04			ldy #4
   284 3422 B1 D3			lda (ns),y
   285 3424 8D 2A 36			sta smc_maxtracklen				; Change the code to store the track length
   286
   287 					; Song speed: +5
   288 3427 C8				iny
   289 					IFT FEAT_CONSTANTSPEED==0
   290 3428 B1 D3				lda (ns),y
   291 342A 8D E2 34				sta smc_speed				; Change the code to store the song speed
   292 					EIF
   293 					
   294 					; Instrument speed: +6
   295 					IFT FEAT_INSTRSPEED==0
   296 342D C8					iny
   297 342E B1 D3				lda (ns),y
   298 3430 8D 1B 36				sta smc_instrspeed			; Change the code to store the instrument speed
   299 3433 8D 8F 34				sta smc_silence_instrspeed
   300 					ELI FEAT_INSTRSPEED>1
   301 						lda #FEAT_INSTRSPEED
   302 						sta smc_silence_instrspeed
   303 					EIF
   304
   305 					; Copy 4 pointers: +8
   306 					; -> InstrumentPtrs[] 	2 bytes
   307 					; -> TracksPtrsLow[]	2 bytes
   308 					; -> TracksPtrsHi		2 bytes
   309 					; -> SongData			2 bytes
   310 3436 A0 08			ldy #8
   311 3438			ri_copy_loop	
   312 3438 B1 D3			lda (ns),y
   313 343A 99 C3 00			sta p_tis-8,y
   314 343D C8				iny
   315 343E C0 10			cpy #8+8						; loop until y is 16
   316 3440 D0 F6			bne ri_copy_loop
   317
   318 					IFT FEAT_NOSTARTINGSONGLINE==0
   319 						; Set the starting song line by moving ptrSongLines forward
   320 3442 68					pla							; Get the saved starting song line
   321 3443 48					pha
   322 						IFT TRACKS>4
   323 							; Stereo
   324 							; ptrSongLines += song_line * 8
   325 3444 0A						asl @					; offset * 8
   326 3445 0A						asl @
   327 3446 0A						asl @
   328 3447 18						clc
   329 3448 65 D1					adc ptrSongLines				; ptrSongLines += offset * 8 (low) part
   330 344A 85 D1					sta ptrSongLines
   331 344C 68						pla						; restore offset, but keep carry bit
   332 344D 08						php						; store flags on stack (carry bit!)
   333 344E 29 E0					and #$e0
   334 3450 0A						asl @
   335 3451 2A						rol @
   336 3452 2A						rol @
   337 3453 2A						rol @
   338 						ELS
   339 							; Mono
   340 							; ptrSongLines += song_line * 4
   341 							asl @
   342 							asl @
   343 							clc
   344 							adc ptrSongLines
   345 							sta ptrSongLines
   346 							pla
   347 							php
   348 							and #$c0
   349 							asl @
   350 							rol @
   351 							rol @
   352 						EIF
   353 3454 28					plp							; restore the carry bit
   354 3455 65 D2				adc ptrSongLines+1
   355 3457 85 D2				sta ptrSongLines+1
   356 					EIF
   357 3459 20 91 34			jsr GetSongLine					; Setup the first song line
   358 					
   359 				;* end of rmt_init code... rmt_silence will always be executed after the JSR above.
   360
   361 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   362 					
   363 				; RMT_SILENCE
   364 				; Reset POKEY causes all sound to be stopped
   365 					
   366 345C			rmt_silence
   367 					; Reset POKEY
   368 					IFT STEREOMODE>0
   369 345C A9 00				lda #0
   370 345E 8D 08 D2				sta $d208			; AUDCTL
   371 3461 8D 18 D2				sta $d218
   372 3464 A0 03				ldy #3
   373 3466 8C 0F D2				sty $d20f			; SKCTL
   374 3469 8C 1F D2				sty $d21f
   375 						; Clear AUDFx & AUDCx
   376 346C A0 08				ldy #8
   377 346E			silence_loop	
   378 346E 99 00 D2				sta $d200,y
   379 3471 99 10 D2				sta $d210,y
   380 3474 88					dey
   381 3475 10 F7				bpl silence_loop
   382 					ELS
   383 						lda #0
   384 						sta $d208
   385 						ldy #3
   386 						sty $d20f
   387 						ldy #8
   388 				silence_loop	
   389 						sta $d200,y	
   390 						dey
   391 						bpl silence_loop
   392 					EIF
   393 					
   394 					IFT FEAT_IS_TRACKER 		; reset the tables pointers 
   395 3477 A9 00			lda #<frqtabsawtooth_ch1	; reset the Sawtooth table inversion
   396 3479 8D 27 3C			sta saw_ch1
   397 347C A9 40			lda #<frqtabsawtooth_ch3
   398 347E 8D 2A 3C			sta saw_ch3	
   399 3481 A9 0A			lda #$0A			; reset the Distortion 6 16-bit pointer
   400 3483 8D 62 3C			sta bass16_pointer 
   401 3486 A9 03			lda #3				; reset the SKCTL state to normal
   402 3488 8D D3 3C			sta v_skctl
   403 348B 8D D5 3C			sta v_skctl2	
   404 					EIF	
   405
   406 					IFT FEAT_INSTRSPEED==0
   407 348E A9 FF				lda #$ff
   408 = 348F			smc_silence_instrspeed equ *-1			; return instrument speed, does not seem to matter after rmt_init?
   409 					ELS
   410 						lda #FEAT_INSTRSPEED
   411 					EIF
   412 3490 60				rts
   413 					
   414 				;* end of rmt_silence code...
   415 					
   416 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   417 					
   418 				;* start of mainloop code here... most of it is related to the songlines, tracklines and instruments initialisation...
   419 					
   420 3491			GetSongLine
   421 3491 A2 00			ldx #0
   422 3493 8E 28 36			stx smc_abeat						; set the pattern row to 0 for the new songline... This could be exploited with an effect command related to premature pattern end, or pattern goto...
   423 3496			gsl_continueProcessing
   424 					IFT FEAT_IS_SIMPLEP
   425 						IFT EXPORTXEX					; Simple RMT Player hack for colour cycling, change the rasterbar colour every new pattern played
   426 							lda loop+1					; the #RASTERBAR colour defined will be loaded there specifically
   427 							add #16						; offset the value by #$10 for a simple colour shuffle
   428 							sta loop+1   				; store back where it was loaded, overwriting the previous value
   429 							lda ptrSongLines					; calculate the songline position below, this is done once every new songline
   430 							sub MODUL+14 				; TODO: relocate this code elsewhere, so toggling it would be easier
   431 							sta v_ord 
   432 							lda ptrSongLines+1
   433 							sbc MODUL+15
   434 							lsr @
   435 							ror v_ord
   436 							lsr @
   437 							ror v_ord
   438 							IFT TRACKS>4
   439 								lsr @
   440 								ror v_ord
   441 							EIF 
   442 						EIF 
   443 					EIF
   444 					
   445 3496			gsl_nextSongLine	
   446 3496 8A				txa								; A = X = Y = 0,1,2,3
   447 3497 A8				tay
   448 3498 B1 D1			lda (ptrSongLines),y			; Get track info from the songline[y]
   449 349A C9 FE			cmp #$fe						; #$FE = Goto songline, #$FF = Empty track
   450 349C B0 2D			bcs gsl_GotoOrEmpty				; if A >= $FE --> gsl_GotoOrEmpty
   451 					; (A) = Real track #
   452 					; Get the ptr to the track data and store it in ptrTracksTblLo
   453 349E A8				tay
   454 349F B1 CD			lda (ptrTracksTblLo),y			; trackn_TblLo[x] = ptrTracksTblLo[y]
   455 34A1 9D 40 30			sta trackn_TblLo,x
   456 34A4 B1 CF			lda (ptrTracksTblHi),y			; trackn_TblHi[x] = ptrTracksTblHi[y]
   457 34A6 9D 48 30			sta trackn_TblHi,x
   458
   459 34A9 A9 00			lda #0
   460 34AB 9D 50 30			sta trackn_idx,x				; reset the track index to 0 trackn_idx[x] = 0
   461
   462 34AE A9 01			lda #1
   463 34B0			gsl_initTrack 	
   464 34B0 9D 58 30			sta trackn_pause,x				; #1 is a new track, #0 is no new track
   465 34B3 A9 80			lda #$80						; Mark that there is no new instrument
   466 34B5 9D B8 30			sta trackn_instrx2,x			; #$80 is negative, will BMI when encountered, meaning no new instrument initialisation
   467 34B8 E8				inx								; ++x
   468 34B9 E0 08			cpx #TRACKS						; if x < TRACKS --> gsl_nextSongLine
   469 34BB D0 D9			bne gsl_nextSongLine
   470
   471 					; Done with data points of a song line, move to the next line
   472 34BD A5 D1			lda ptrSongLines				; ptrSontLines += #TRACKS (4 or 8)
   473 34BF 18				clc	
   474 34C0 69 08			adc #TRACKS
   475 34C2 85 D1			sta ptrSongLines
   476 34C4 90 1B			bcc GetTrackLine
   477 34C6 E6 D2			inc ptrSongLines+1
   478 					
   479 34C8 4C E1 34			jmp GetTrackLine				; Now progress the notes in a track
   480
   481 34CB			gsl_GotoOrEmpty
   482 34CB F0 04			beq gsl_thisIsAGoto				; branch if equal to #$FE, this is a Goto songline command
   483
   484 34CD A9 00			lda #0							; Used to set the instrument to 0, meaning no new track
   485 34CF F0 DF			beq gsl_initTrack				; unconditional
   486
   487 34D1			gsl_thisIsAGoto
   488 					; Data format: 0xFE, 0x00, low, high bytes of ptr to next song line
   489 34D1 A0 02			ldy #2
   490 34D3 B1 D1			lda (ptrSongLines),y			; lo = ptrSongLines[2]
   491 34D5 AA				tax
   492 34D6 C8				iny
   493 34D7 B1 D1			lda (ptrSongLines),y			; hi = ptrSongLinex[3]
   494 34D9 85 D2			sta ptrSongLines+1
   495 34DB 86 D1			stx ptrSongLines				; (ptrSongLines) = ptrSongLines[2,3]
   496 34DD A2 00			ldx #0
   497 34DF F0 B5			beq gsl_continueProcessing
   498
   499 				; Process one line of a track
   500 34E1			GetTrackLine
   501 					IFT FEAT_CONSTANTSPEED==0
   502 34E1 A9 FF				lda #$ff					; This value is changed by the code
   503 = 34E2			smc_speed equ *-1					; ptr to #$ff location in the code
   504 34E3 8D 35 35				sta smc_bspeed
   505 					EIF
   506 34E6 A2 FF			ldx #$ff						;-1 track data index
   507 34E8			gtl_loopTracks
   508 34E8 E8				inx								; 0,1, .. #TRACKS
   509 34E9 DE 58 30			dec trackn_pause,x				; --trackn_pause[x]
   510 34EC D0 42			bne gtl_checkEndOfLoop			; if trackn_pause[x] != 0 --> gtl_checkEndOfLoop
   511
   512 					; Setup ptr to track data
   513 34EE BD 40 30			lda trackn_TblLo,x				; (ns) = trackn_TblLo/hi[x]
   514 34F1 85 D3			sta ns
   515 34F3 BD 48 30			lda trackn_TblHi,x
   516 34F6 85 D4			sta ns+1
   517 34F8			oo1i
   518 34F8 BC 50 30			ldy trackn_idx,x				; Y = index into track data
   519 34FB FE 50 30			inc trackn_idx,x				; ++trackn_idx[x]
   520 					; Get a track data point
   521 					; 0 - 60 = Note, instr and volume data
   522 					; 61 - Volume only
   523 					; 62 = Pause/empty line
   524 					; 63 - Speed, go loop or end
   525 34FE B1 D3			lda (ns),y						; reg1 = A = ns[y]
   526 3500 85 D9			sta reg1
   527 3502 29 3F			and #$3f						; 0-63
   528 3504 C9 3D			cmp #61							; 61 = Volume only
   529 3506 F0 0E			beq gtl_ProcessVolumeData
   530 3508 B0 35			bcs gtl_Is62or63
   531 					; Not a command so store the note
   532 350A 9D 60 30			sta trackn_note,x				; note[x] = data & 0x3f
   533
   534 					; Process the instrument #
   535 350D C8				iny
   536 350E B1 D3			lda (ns),y						; instr = (data & 0xfc) >> 1
   537 3510 4A				lsr
   538 3511 29 7E			and #$3f*2
   539 3513 9D B8 30			sta trackn_instrx2,x			; trackn_instrx2[x] = instrument # * 2
   540
   541 3516			gtl_ProcessVolumeData
   542 3516 A9 01			lda #1
   543 3518 9D 58 30			sta trackn_pause,x				; got a note
   544
   545 					; Get the volume
   546 351B BC 50 30			ldy trackn_idx,x				; y = track index
   547 351E FE 50 30			inc trackn_idx,x				; move to the next data point in the track
   548 3521 B1 D3			lda (ns),y
   549 3523 4A				lsr
   550 3524 66 D9			ror reg1
   551 3526 4A				lsr
   552 3527 66 D9			ror reg1
   553 3529 A5 D9			lda reg1
   554 					IFT FEAT_GLOBALVOLUMEFADE
   555 					sec
   556 					sbc #$00
   557 				RMTGLOBALVOLUMEFADE equ *-1
   558 					bcs voig
   559 					lda #0
   560 				voig
   561 					EIF
   562 352B 29 F0			and #$f0
   563 352D 9D 68 30			sta trackn_volume,x
   564 3530			gtl_checkEndOfLoop	
   565 3530 E0 07			cpx #TRACKS-1
   566 3532 D0 B4			bne gtl_loopTracks
   567
   568 					IFT FEAT_CONSTANTSPEED==0
   569 3534 A9 FF				lda #$ff					; This value is changed by the code
   570 = 3535			smc_bspeed equ *-1					; ptr to #$ff location in the code
   571 3536 8D E2 34				sta smc_speed
   572 					ELS
   573 						lda #FEAT_CONSTANTSPEED
   574 					EIF
   575 3539 8D 88 31			sta v_aspeed
   576 353C 4C 84 35			jmp InitOfNewSetInstrumentsOnly
   577 					
   578 353F			gtl_Is62or63
   579 353F C9 3F			cmp #63
   580 3541 F0 1B			beq oo63
   581 3543 A5 D9			lda reg1
   582 3545 29 C0			and #$c0
   583 3547 F0 09			beq oo62_b
   584 3549 0A				asl @
   585 354A 2A				rol @
   586 354B 2A				rol @
   587 354C 9D 58 30			sta trackn_pause,x
   588 354F 4C 30 35			jmp gtl_checkEndOfLoop
   589 3552			oo62_b
   590 3552 C8				iny
   591 3553 B1 D3			lda (ns),y
   592 3555 9D 58 30			sta trackn_pause,x
   593 3558 FE 50 30			inc trackn_idx,x
   594 355B 4C 30 35			jmp gtl_checkEndOfLoop
   595 355E			oo63
   596 355E A5 D9			lda reg1
   597 					IFT FEAT_CONSTANTSPEED==0
   598 3560 30 0C				bmi oo63_1X
   599 3562 C8					iny
   600 3563 B1 D3				lda (ns),y
   601 3565 8D 35 35				sta smc_bspeed				; Set the song speed
   602 3568 FE 50 30				inc trackn_idx,x
   603 356B 4C F8 34				jmp oo1i
   604 356E			oo63_1X
   605 					EIF
   606 356E C9 FF			cmp #255
   607 3570 F0 09			beq oo63_11
   608 3572 C8				iny
   609 3573 B1 D3			lda (ns),y
   610 3575 9D 50 30			sta trackn_idx,x
   611 3578 4C F8 34			jmp oo1i
   612 357B			oo63_11
   613 357B 4C 91 34			jmp GetSongLine
   614 					
   615 357E			p2xrmtp3	
   616 357E 4C 33 36			jmp rmt_p3
   617 3581			p2x0 	
   618 3581 CA				dex
   619 3582 30 FA			bmi p2xrmtp3
   620 					
   621 3584			InitOfNewSetInstrumentsOnly
   622 3584			p2x1 	
   623 3584 BC B8 30			ldy trackn_instrx2,x
   624 3587 30 F8			bmi p2x0		; if negative, there is no new instrument to initialise for this channel
   625 					
   626 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   627
   628 				;* start of RMT_SFX code...
   629 					
   630 					IFT FEAT_SFX
   631 					jsr SetUpInstrumentY2
   632 					jmp p2x0
   633 				rmt_sfx
   634 					sta trackn_note,x
   635 					lda #$f0		;* sfx note volume*16
   636 				RMTSFXVOLUME equ *-1		;* label for sfx note volume parameter overwriting
   637 					sta trackn_volume,x
   638 					EIF
   639 					
   640 				;* end of RMT_SFX code...
   641
   642 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   643 					
   644 3589			SetUpInstrumentY2
   645 3589 B1 CB			lda (ptrInstrumentTbl),y
   646 358B 9D C0 30			sta trackn_instrdb,x
   647 358E 85 D7			sta nt
   648 3590 C8				iny
   649 3591 B1 CB			lda (ptrInstrumentTbl),y
   650 3593 9D C8 30			sta trackn_instrhb,x
   651 3596 85 D8			sta nt+1
   652 					
   653 					IFT FEAT_FILTER
   654 				;		lda #1
   655 3598 A9 00			lda #0			;* EXPERIMENTAL approach for more precise manipulation of the PWM
   656 359A 9D 58 31			sta trackn_filter,x	; set the offset value to 0 on new notes always
   657 359D 09 01			ora #1			; the value of 1 is expected here, so just provide it I guess
   658 					EIF
   659 					
   660 					IFT FEAT_TABLEGO
   661 					IFT FEAT_FILTER
   662 359F A8				tay
   663 					ELS
   664 					ldy #1
   665 					EIF
   666 35A0 B1 D7			lda (nt),y
   667 35A2 9D 48 31			sta trackn_tablelop,x
   668 35A5 C8				iny
   669 					ELS
   670 					ldy #2
   671 					EIF
   672 35A6 B1 D7			lda (nt),y
   673 35A8 9D D8 30			sta trackn_instrlen,x
   674 35AB C8				iny
   675 35AC B1 D7			lda (nt),y
   676 35AE 9D E0 30			sta trackn_instrlop,x
   677 35B1 C8				iny
   678 35B2 B1 D7			lda (nt),y
   679 35B4 9D 20 31			sta trackn_tabletypespeed,x
   680 					IFT FEAT_TABLETYPE||FEAT_TABLEMODE
   681 35B7 29 3F			and #$3f
   682 					EIF
   683 35B9 9D 50 31			sta trackn_tablespeeda,x
   684 					IFT FEAT_TABLEMODE
   685 35BC B1 D7			lda (nt),y
   686 35BE 29 40			and #$40
   687 35C0 9D 28 31			sta trackn_tablemode,x
   688 					EIF
   689 					IFT FEAT_AUDCTLMANUALSET
   690 35C3 C8				iny
   691 35C4 B1 D7			lda (nt),y
   692 35C6 9D 70 31			sta trackn_audctl,x
   693 35C9 C8				iny
   694 					ELS
   695 					ldy #6
   696 					EIF
   697 35CA B1 D7			lda (nt),y
   698 35CC 9D F0 30			sta trackn_volumeslidedepth,x
   699 					IFT FEAT_VOLUMEMIN
   700 35CF C8				iny
   701 35D0 B1 D7			lda (nt),y
   702 35D2 9D 00 31			sta trackn_volumemin,x
   703 					IFT FEAT_EFFECTS
   704 35D5 C8				iny
   705 					EIF
   706 					ELS
   707 					IFT FEAT_EFFECTS
   708 					ldy #8
   709 					EIF
   710 					EIF
   711 					IFT FEAT_EFFECTS
   712 35D6 B1 D7			lda (nt),y
   713 35D8 9D 08 31			sta trackn_effdelay,x
   714 					IFT FEAT_EFFECTVIBRATO
   715 35DB C8				iny
   716 35DC B1 D7			lda (nt),y
   717 35DE A8				tay
   718 35DF B9 18 32			lda vibtabbeg,y
   719 35E2 9D 10 31			sta trackn_effvibratoa,x
   720 					EIF
   721 					IFT FEAT_EFFECTFSHIFT
   722 35E5 A0 0A			ldy #10
   723 35E7 B1 D7			lda (nt),y
   724 35E9 9D 18 31			sta trackn_effshift,x
   725 					EIF
   726 					EIF
   727 					IFT FEAT_TABLE_MANUAL	; Manual tuning table loaded from instruments, based on the unused 12th byte, this is not yet fully implemented into RMT
   728 					ldy #11
   729 					lda (nt),y
   730 					sta trackn_pointertable,x	
   731 					EIF
   732 35EC A9 80			lda #128
   733 35EE 9D F8 30			sta trackn_volumeslidevalue,x
   734 35F1 9D B8 30			sta trackn_instrx2,x
   735 35F4 0A				asl @
   736 35F5 9D E8 30			sta trackn_instrreachend,x
   737 35F8 9D 88 30			sta trackn_shiftfrq,x
   738 35FB A8				tay
   739 35FC B1 D7			lda (nt),y
   740 35FE 9D 40 31			sta trackn_tableend,x
   741 3601 69 00			adc #0
   742 3603 9D D0 30			sta trackn_instridx,x
   743 3606 A9 0C			lda #INSTRPAR
   744 3608 9D 38 31			sta trackn_tablea,x
   745 360B A8				tay
   746 360C B1 D7			lda (nt),y
   747 360E 9D 30 31			sta trackn_tablenote,x
   748
   749 					IFT FEAT_SFX||FEAT_IS_TRACKER
   750 3611 60				rts 			
   751 				;* a rts is mandatory for the 'tracker.obx' binary, else a lot of things break in RMT! 
   752 				;* look inside 'rmtextra.a65' for the exclusive tracker.obx code
   753 					ELS
   754 					jmp p2x0		; go process the next channel's instrument
   755 					EIF
   756
   757 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   758
   759 3612			rmt_play
   760 3612			rmt_p0
   761 3612 20 68 3C			jsr SetPokey
   762 					
   763 3615			rmt_p1
   764 					IFT FEAT_INSTRSPEED==0||FEAT_INSTRSPEED>1
   765 3615 CE 8F 34				dec smc_silence_instrspeed
   766 3618 D0 19				bne rmt_p3
   767 					EIF
   768 					IFT FEAT_INSTRSPEED==0
   769 361A A9 FF				lda #$ff
   770 = 361B			smc_instrspeed	equ *-1				; ptr to #$ff location in the code
   771 361C 8D 8F 34				sta smc_silence_instrspeed
   772 					ELI FEAT_INSTRSPEED>1
   773 						lda #FEAT_INSTRSPEED
   774 						sta smc_silence_instrspeed
   775 					EIF
   776 					
   777 361F			rmt_p2
   778 361F CE 88 31			dec v_aspeed
   779 3622 D0 0F			bne rmt_p3
   780 3624 EE 28 36			inc smc_abeat					; ++smc_abeat
   781 3627 A9 FF			lda #$ff						; if (smc_abeat == smc_maxtracklen) GetSongLine else GetTrackLine
   782 = 3628			smc_abeat equ *-1					; smc_abeat is the index into the track
   783 3629 C9 FF			cmp #$ff
   784 = 362A			smc_maxtracklen equ *-1
   785 362B F0 03			beq p2o3
   786 362D 4C E1 34			jmp GetTrackLine
   787 3630			p2o3
   788 3630 4C 91 34			jmp GetSongLine
   789
   790 3633			rmt_p3	
   791 3633 A2 07			ldx #TRACKS-1
   792
   793 				;*
   794 				;* Aggressive initialisation every new player call here, the method was originally done to get the AUDCTL early, but many things can be exploited here the same way.
   795 				;* Combining the aggressive init and rmt_p3 in 1 thing, this is now an even more aggressive approach! 
   796 				;*
   797 				;* POSSIBLE IMPROVEMENT: process ALL effect commands here instead... Meaning there won't be workarounds necessary later, for several commands.
   798 				;* Example: Get AUDCTL early, get Effect values early, process instrument accordingly afterwards.
   799 				;* Doing certain things in a different order might drastically speed up several parts that end up being redundant or even overwritten later during certain effects like AUTOFILTER or BASS16.
   800 				;* Let's say, process 16-bit here... in such case, there won't be anything stopping the player to know it can safely skip a channel's instrument if it was going to be overwritten anyway...
   801 				;* This is purely speculation, however, so what is done here currently does the job, at least. This is still very different from the original RMT driver code as it is.
   802 				;* 
   803 					
   804 3635			dodex	
   805 3635 BD C8 30			lda trackn_instrhb,x
   806 3638 F0 42			beq dexnext			; process the next channel's bytes immediately if empty
   807 363A 85 D4			sta ns+1
   808 363C BD C0 30			lda trackn_instrdb,x
   809 363F 85 D3			sta ns
   810 3641 BC D0 30			ldy trackn_instridx,x
   811 3644 B1 D3			lda (ns),y			; volume byte	
   812 3646 9D 70 30			sta trackn_volumeenvelope,x	; sta reg1
   813 3649 C8				iny
   814 364A B1 D3			lda (ns),y			; command and distortion byte
   815 364C 9D 78 30			sta trackn_command,x		; sta reg2
   816 364F C8				iny
   817 3650 B1 D3			lda (ns),y			; $XY parameter byte
   818 3652 9D 80 30			sta trackn_effectparameter,x	; sta reg3
   819 3655 C8				iny
   820 3656 98				tya
   821 3657 DD D8 30			cmp trackn_instrlen,x
   822 365A 90 0A			bcc dodex_a
   823 365C F0 08			beq dodex_a
   824 365E A9 80			lda #$80
   825 3660 9D E8 30			sta trackn_instrreachend,x
   826 3663 BD E0 30			lda trackn_instrlop,x
   827 3666			dodex_a
   828 3666 9D D0 30			sta trackn_instridx,x
   829
   830 					IFT FEAT_AUDCTLMANUALSET&&FEAT_COMMAND7		; POSSIBLE IMPROVEMENT: process the Two-Tone Filter commands here instead, leaving CMD7 only useful for Volume Only checks later
   831 3669			dex_cmd7	
   832 3669 BD 78 30				lda trackn_command,x
   833 366C 29 70				and #$70					; clear distortion and other bits
   834 366E C9 70				cmp #$70 					; command 7? 
   835 3670 D0 0A				bne dexnext					; skip if not equal
   836 3672 BD 80 30				lda trackn_effectparameter,x	
   837 3675			dex_xy
   838 3675 C9 FD				cmp #$FD					; failsafe -> Volume Only Mode or SKCTL toggle 
   839 3677 B0 03				bcs dexnext					; skip if above or equal #$FD 
   840 3679 9D 70 31				sta trackn_audctl,x			; overwrite the previous value	
   841 					EIF
   842 					
   843 367C			dexnext
   844 367C CA				dex
   845 367D 10 B6			bpl dodex			; continue until x is negative
   846 					
   847 				;* FORCE ALL INSTRUMENTS TO USE THE SAME AUDCTL TO NOT OVERLAP IN PRIORITY-- DOESNT WORK LIKE THAT FUCK, HOW COULD I FORCE A AUDCTL CLEAR ON A CHANNEL ABOVE ONE I AM USING?
   848 				;* Ideally... what would be even better is to have a global effect channel... y'know, like a music tracker? That could also be useful for setting certain global values like tempo, note offset, etc 	
   849
   850 367F			pp0	
   851
   852 				;* get AUDCTL as early as possible, properly this time!
   853
   854 					IFT FEAT_AUDCTLMANUALSET
   855 367F AD 70 31				lda trackn_audctl+0
   856 3682 0D 71 31				ora trackn_audctl+1
   857 3685 0D 72 31				ora trackn_audctl+2
   858 3688 0D 73 31				ora trackn_audctl+3
   859 368B 8D 69 3C				sta v_audctl
   860 					
   861 						;* Assign flags early here as soon as possible 
   862 						
   863 						IFT FEAT_FULL_16BIT||FEAT_BASS16||FEAT_FULL_SAWTOOTH 
   864 368E A8						tay				; backup the now combined audctl for the flags attribution 
   865 368F 29 01					and #1				; 64khz == 0, 15khz == 1 always, the other flags will then take priority over this
   866 3691 8D 68 31					sta g_flag+0			; ch1
   867 3694 8D 69 31					sta g_flag+1			; ch2
   868 3697 8D 6A 31					sta g_flag+2			; ch3
   869 369A 8D 6B 31					sta g_flag+3			; ch4
   870 369D 98						tya				; get the AUDCTL back for the BIT tests below 
   871 369E			pp0_a	
   872 369E 2C 01 32					bit CH1_179
   873 36A1 F0 12					beq pp0_d			; BNE => 1.79mhz, BEQ => Nothing, skip the next BIT test 	
   874 36A3 2C 03 32					bit JOIN_12
   875 36A6 D0 04					bne pp0_b			; BNE => 16-bit, BEQ => 1.79mhz 
   876 36A8 A2 40					ldx #$40			; 1.79mhz pointer
   877 36AA D0 06					bne pp0_c			; unconditional 
   878 36AC			pp0_b
   879 36AC A2 80					ldx #$80			; 16-bit pointer
   880 36AE 8E 69 31					stx g_flag+1			; flag set in ch2
   881 36B1 CA						dex				; #$80 becomes #$7F
   882 36B2			pp0_c		
   883 36B2 8E 68 31					stx g_flag+0			; flag set in ch1
   884 36B5			pp0_d 
   885 36B5 2C 02 32					bit CH3_179 
   886 36B8 F0 12					beq pp0_g			; BNE => 1.79mhz, BEQ => Nothing, skip the next BIT test 
   887 36BA 2C 04 32					bit JOIN_34
   888 36BD D0 04					bne pp0_e			; BNE => 16-bit, BEQ => 1.79mhz 
   889 36BF A2 40					ldx #$40			; 1.79mhz pointer
   890 36C1 D0 06					bne pp0_f			; unconditional 
   891 36C3			pp0_e
   892 36C3 A2 80					ldx #$80			; 16-bit pointer
   893 36C5 8E 6B 31					stx g_flag+3			; flag set in ch4 
   894 36C8 CA						dex				; #$80 becomes #$7F 
   895 36C9			pp0_f		
   896 36C9 8E 6A 31					stx g_flag+2			; flag set in ch3 
   897 36CC			pp0_g 
   898 						EIF
   899 					
   900 						IFT TRACKS>4			; Stereo 
   901 36CC AD 74 31					lda trackn_audctl+4
   902 36CF 0D 75 31					ora trackn_audctl+5
   903 36D2 0D 76 31					ora trackn_audctl+6
   904 36D5 0D 77 31					ora trackn_audctl+7
   905 36D8 8D CB 3C					sta v_audctl2
   906
   907 							IFT FEAT_FULL_16BIT||FEAT_BASS16||FEAT_FULL_SAWTOOTH 
   908 36DB A8							tay				; backup the now combined audctl for the flags attribution 
   909 36DC 29 01						and #1				; 64khz == 0, 15khz == 1 always, the other flags will then take priority over this
   910 36DE 8D 6C 31						sta g_flag+0+4			; ch1
   911 36E1 8D 6D 31						sta g_flag+1+4			; ch2
   912 36E4 8D 6E 31						sta g_flag+2+4			; ch3
   913 36E7 8D 6F 31						sta g_flag+3+4			; ch4
   914 36EA 98							tya				; get the AUDCTL back for the BIT tests below 
   915 36EB			pp0_h	
   916 36EB 2C 01 32						bit CH1_179
   917 36EE F0 12						beq pp0_k			; BNE => 1.79mhz, BEQ => Nothing, skip the next BIT test 	
   918 36F0 2C 03 32						bit JOIN_12
   919 36F3 D0 04						bne pp0_i			; BNE => 16-bit, BEQ => 1.79mhz 
   920 36F5 A2 40						ldx #$40			; 1.79mhz pointer
   921 36F7 D0 06						bne pp0_j			; unconditional 
   922 36F9			pp0_i
   923 36F9 A2 80						ldx #$80			; 16-bit pointer
   924 36FB 8E 6D 31						stx g_flag+1+4			; flag set in ch2
   925 36FE CA							dex				; #$80 becomes #$7F
   926 36FF			pp0_j		
   927 36FF 8E 6C 31						stx g_flag+0+4			; flag set in ch1
   928 3702			pp0_k 
   929 3702 2C 02 32						bit CH3_179 
   930 3705 F0 12						beq pp0_n			; BNE => 1.79mhz, BEQ => Nothing, skip the next BIT test 
   931 3707 2C 04 32						bit JOIN_34
   932 370A D0 04						bne pp0_l			; BNE => 16-bit, BEQ => 1.79mhz 
   933 370C A2 40						ldx #$40			; 1.79mhz pointer
   934 370E D0 06						bne pp0_m			; unconditional 
   935 3710			pp0_l
   936 3710 A2 80						ldx #$80			; 16-bit pointer
   937 3712 8E 6F 31						stx g_flag+3+4			; flag set in ch4 
   938 3715 CA							dex				; #$80 becomes #$7F 
   939 3716			pp0_m		
   940 3716 8E 6E 31						stx g_flag+2+4			; flag set in ch3 
   941 3719			pp0_n 
   942 							EIF	
   943 						EIF
   944 					ELS
   945 						lda #0
   946 						sta v_audctl
   947 						IFT TRACKS>4
   948 							sta v_audctl2
   949 						EIF
   950 					EIF
   951
   952 3719			pp0_o
   953 3719 A2 07			ldx #TRACKS-1			; must get the tracks value again before the next part
   954
   955 371B			pp1					; copying the values to the zeropage to make things faster... but not all bytes need this...
   956
   957 				;* OPTIMISATION: reg1 is now free to use for a different purpose! 
   958
   959 371B BD C8 30			lda trackn_instrhb,x
   960 371E D0 03			bne pp1_b			; continue if not equal 
   961 3720 4C E4 3A			jmp ppnext			; skip this channel and process the next one
   962 3723			pp1_b
   963 3723 BD 68 31			lda g_flag,x			; AUDCTL flags
   964 3726 85 D9			sta reg1			; backup to the zeropage for quicker accesses
   965 3728 BD 78 30			lda trackn_command,x		; command and distortion byte
   966 372B 85 DA			sta reg2			; backup to the zeropage for quicker accesses
   967 372D BD 80 30			lda trackn_effectparameter,x	; $XY parameter byte
   968 3730 85 DB			sta reg3			; backup to the zeropage for quicker accesses
   969 					
   970 3732			pp2
   971 3732 BD 70 30			lda trackn_volumeenvelope,x	; volume envelope byte
   972 					IFT TRACKS>4
   973 3735 E0 04				cpx #4
   974 3737 90 04				bcc pp2s
   975 3739 4A					lsr @
   976 373A 4A					lsr @
   977 373B 4A					lsr @
   978 373C 4A					lsr @
   979 					EIF
   980 373D			pp2s
   981 373D 29 0F			and #$0f
   982 373F 1D 68 30			ora trackn_volume,x
   983 3742 A8				tay
   984 3743 B9 00 33			lda volumetab,y
   985 3746 85 DC			sta tmp				; backup the resulting volume here, it will then used to make the AUDC value a bit later
   986
   987 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   988
   989 				;* start of manual tables code (unfinished)...
   990
   991 					IFT FEAT_TABLE_MANUAL		; Manual tuning table loaded from instruments, this is currently not fully implemented into RMT...
   992 						lda trackn_pointertable,x
   993 						beq do_tuning_tables		; a value of 0 means no pointer will be used, thus, can be skipped immediately
   994 						tay
   995 						and #$0F
   996 						ora #$B0
   997 						sta nr+1			; Bx00, where x is manipulated
   998 				;* hack for Reverse-16 proof of concept, won't be used later		
   999 						lda #0
  1000 						cpx #1
  1001 						bne stayzero
  1002 				;* end hack
  1003 						tya
  1004 						and #$C0
  1005 				stayzero	
  1006 						sta nr				; B0x0, where is manipulated
  1007 					;* hack for Reverse-16 proof of concept, won't be used later	 
  1008 						cpx #0
  1009 						bne getdist
  1010 						lda tmp
  1011 						ora #$C0	
  1012 						jmp store_tables_lsb_c 
  1013 					;* end of Reverse-16 hack, what is below should always be the same 
  1014 				getdist	
  1015 						lda reg2
  1016 						and #$0e
  1017 						tay
  1018 						jmp store_tables_lsb_b
  1019 					EIF
  1020 					
  1021 				;* end of manual tables code...
  1022 					
  1023 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1024 					
  1025 				;* start of the tuning tables code... 
  1026
  1027 				;*
  1028 				;* POSSIBLE IMPROVEMENT: make a JMP table indexed by X, instead of these dumb 1 by 1 checks... now done?
  1029 				;* ANOTEHR POSSIBLE IMPROVEMENT: get the combined Distortion and Volume value as soon as possible, then get the tables pointer loaded...
  1030 				;*
  1031 				;* This may potentially debloat a lot of this part, and make things much faster as well 
  1032 				;* AUDCTL BIT bytes could also be snuck in between the JMPs, replacing the NOPs, saving some space too! 
  1033 				;* In fact, a lot of the things here need to get improved a lot more... 6502 ASM is hard!!!
  1034 				;*
  1035
  1036 3748			do_tuning_tables
  1037 3748 A5 DA			lda reg2		; Distortion and Command
  1038 374A 29 0E			and #$0E		; Only keep the Distortion bits
  1039 374C A8				tay			; will be used for the tables MSB pointer, and the Distortion itself	
  1040 						
  1041 					IFT FEAT_AUDCTLMANUALSET	;*!!!! big block begins here 
  1042
  1043 						IFT FEAT_FULL_16BIT||FEAT_BASS16
  1044 374D A5 D9					lda reg1		; load the channel flag for the initial 16-bit checks
  1045 374F 30 7B					bmi get_16bit_flag	; 16-bit MSB flag detected, jump and finish there immediately 	
  1046 3751 C9 7F					cmp #$7F		; 16-bit LSB flag
  1047 3753 90 08					bcc check_index		; if not #$7F, the index checks will take care of everything else
  1048 							
  1049 							;lda trackn_bass16,x	; get the LSB pitch value
  1050 							;sta trackn_audf,x	; and write into the appropriate channel! -- BUG! This may be skipped entirely, unfortunately
  1051 							
  1052 3755 A9 00					lda #0			; the 16-bit LSB flag was set, so first load 0
  1053 3757 9D 80 31					sta trackn_audc,x	; then mute the channel
  1054 							;sta trackn_bass16,x	; and reset the LSB value before the next call-- BUG? if this is not done, the channel seems to outputs garbage on certain commands, why does this happen?
  1055 375A 4C E4 3A					jmp ppnext		; and finish this one early, there is nothing else to do here!
  1056 						EIF
  1057
  1058 375D			check_index			; IMPROVEMENT: the flags system should work much better this time!
  1059 375D 8A					txa
  1060 						IFT TRACKS>4		; stereo mode 	
  1061 375E E0 04					cpx #4			; are we in the right POKEY channels?
  1062 3760 90 02					bcc check_index_a	; if x is below 4, we are not 
  1063 3762 E9 04					sbc #4			; carry is set, 4 will be subtracted 
  1064 						EIF 
  1065 3764			check_index_a
  1066 3764 0A					asl @ 
  1067 3765 0A					asl @ 
  1068 3766 8D 6C 37				sta c_index+1
  1069 3769 A5 D9				lda reg1		; load the channel flag back in memory for the upcoming checks
  1070 376B 90 FE		c_index	bcc *
  1071 376D 4C 7C 37				jmp check_ch1 
  1072 3770 EA					nop
  1073 3771 4C 93 37				jmp check_ch2
  1074 3774 EA					nop
  1075 3775 4C A0 37				jmp check_ch3
  1076 3778 EA					nop
  1077 3779 4C A6 37				jmp check_ch4 
  1078
  1079 377C			check_ch1 
  1080 						IFT FEAT_FULL_SAWTOOTH
  1081 377C C9 40					cmp #$40 		; 1.79mhz flag 
  1082 377E D0 35					bne get_15khz_flag	; no Sawtooth and no 1.79mhz if not equal
  1083 3780 C0 0A					cpy #$0A		; Distortion A?
  1084 3782 D0 4C					bne store_tables_lsb	; no Sawtooth if not equal, but the 1.79mhz flag is set! 
  1085 3784 A5 DC					lda tmp			; volume value backup
  1086 3786 F0 07					beq check_ch1_a		; no Sawtooth if the volume is 0
  1087 3788 A5 DA					lda reg2 		; commands backup 
  1088 378A 10 03					bpl check_ch1_a		; no Sawtooth if the AUTOFILTER command is off 
  1089 378C 4C E9 3B					jmp do_sawtooth		; if all checks passed, process the Sawtooth code from here 
  1090 378F			check_ch1_a
  1091 378F A5 D9					lda reg1
  1092 3791 10 3D					bpl store_tables_lsb	; 1.79mhz flag is still set, finish like normal 
  1093 						ELS			; no Sawtooth code 
  1094 							bpl check_ch3		; the 1.79mhz flag is the same regardless of the channel used, saves some bytes
  1095 						EIF
  1096 					
  1097 3793			check_ch2 
  1098 						IFT FEAT_BASS16
  1099 3793 C0 06					cpy #$06		; Distortion 6?
  1100 3795 D0 1E					bne get_15khz_flag	; if not equal, no BASS16	
  1101 3797 A5 DC					lda tmp 		; volume value backup
  1102 3799 F0 18					beq reload_flag		; if the volume is 0, no BASS16	
  1103 379B A9 50					lda #$50		; JOIN_12 + CH1_179 bits 
  1104 379D 4C 34 3C					jmp do_bass16		; if all checks passed, process the BASS16 code from here 	
  1105 						ELS 
  1106 							bpl get_15khz_flag	; there is nothing else to check, unconditional 
  1107 						EIF
  1108 					
  1109 37A0			check_ch3 
  1110 37A0 C9 40				cmp #$40 		; 1.79mhz flag 
  1111 37A2 F0 2C				beq store_tables_lsb	; yes! finish from there
  1112 37A4 D0 0F				bne get_15khz_flag	; there is nothing else to check, unconditional 
  1113 					
  1114 37A6			check_ch4 
  1115 						IFT FEAT_BASS16
  1116 37A6 C0 06					cpy #$06		; Distortion 6?
  1117 37A8 D0 0B					bne get_15khz_flag	; if not equal, no BASS16
  1118 37AA A5 DC					lda tmp 		; volume value backup
  1119 37AC F0 05					beq reload_flag		; if the volume is 0, no BASS16	
  1120 37AE A9 28					lda #$28		; JOIN_34 + CH3_179 bits 
  1121 37B0 4C 34 3C					jmp do_bass16		; if all checks passed, process the BASS16 code from here
  1122 37B3			reload_flag
  1123 37B3 A5 D9					lda reg1 		;* reload the channel flag if no longer in memory before the 15khz checks! 
  1124 						EIF 
  1125
  1126 				;* from here, the flag MUST be in memory, so reload it unless it is 100% certain it is ready to use! 
  1127 					
  1128 37B5			get_15khz_flag
  1129 37B5 29 01				and #1			; #$01 == 15khz flag, unconditional 
  1130 37B7 F0 17				beq store_tables_lsb	; #$00 == 64khz flag, unconditional
  1131 					
  1132 37B9			check_15khz 
  1133 37B9 C0 0C				cpy #$0C		; are we in Distortion C/E?
  1134 37BB B0 04				bcs check_15khz_b	; if equal or above, use the Distortion C 15khz table, else, use the Distortion A 15khz table
  1135 37BD A9 80				lda #<frqtabpure_15khz	; Distortion A 15khz table LSB
  1136 37BF 90 02				bcc check_15khz_c	; carry flag still set
  1137 37C1			check_15khz_b
  1138 37C1 A9 C0				lda #<frqtabbuzzy_15khz	; Distortion C 15khz table LSB
  1139 37C3			check_15khz_c
  1140 37C3 85 D5				sta nr
  1141 37C5 A9 B5				lda #>PAGE_EXTRA_0	; tables MSB pointer, it's the same one regardless of the table used
  1142 37C7 D0 0C				bne store_tables_lsb_a	; unconditional 
  1143 					
  1144 						IFT FEAT_FULL_16BIT 
  1145 37C9			goto_bass16
  1146 37C9 4C 52 3C					jmp do_bass16_c		; go directly in the BASS16 code handling the CMD6 hijack, skipping the AUDCTL update
  1147 37CC			get_16bit_flag
  1148 37CC C0 06					cpy #$06		; Distortion 6?
  1149 37CE F0 F9					beq goto_bass16		; yes! finish from there 
  1150 						EIF
  1151 					
  1152 					EIF			;*!!! end of condition FEAT_AUDCTLMANUALSET
  1153 					
  1154 37D0			store_tables_lsb
  1155 37D0 85 D5			sta nr			; tables LSB pointer, divided in slices of 64 bytes each	
  1156 37D2 B9 08 32			lda TABLES_MSB,y	; 64khz, 1.79mhz and 16-bit all use their flag directly, #$00, #$40 and #$80 are valid pointers! 
  1157 					
  1158 37D5			store_tables_lsb_a
  1159 37D5 85 D6			sta nr+1		; tables MSB pointer, which is the memory page used for tables divided based on their Distortion
  1160 					
  1161 37D7			store_tables_lsb_b
  1162 37D7 A5 DC			lda tmp			; volume value backup
  1163 37D9 19 09 32			ora DISTORTIONS,y	; merge the Distortion and Volume values
  1164 37DC			store_tables_lsb_c
  1165 37DC 9D 80 31			sta trackn_audc,x	; update the channel's AUDC for the next SetPokey subroutine call
  1166 					
  1167 				;* end of tuning tables code...
  1168
  1169 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1170 					
  1171 				;* start of instruments effect code...
  1172 					
  1173 37DF			InstrumentsEffects
  1174 					IFT FEAT_EFFECTS
  1175 37DF BD 08 31				lda trackn_effdelay,x
  1176 37E2 F0 21				beq ei2
  1177 					
  1178 				; possible improvement: use CMP #2 instead? This could save a CLC instruction...
  1179 				;	cmp #2			; if A >= 2 -> skip, 
  1180 				;	bcs ei1			; if A < 2 -> carry flag not set, so it must be A = 1, 0 was done with beq ei2
  1181 					
  1182 37E4 C9 01				cmp #1
  1183 37E6 D0 1A				bne ei1
  1184 37E8 BD 88 30				lda trackn_shiftfrq,x
  1185 						IFT FEAT_EFFECTFSHIFT
  1186 37EB 18						clc
  1187 37EC 7D 18 31					adc trackn_effshift,x
  1188 						EIF
  1189 						IFT FEAT_EFFECTVIBRATO
  1190 37EF 18						clc
  1191 37F0 BC 10 31					ldy trackn_effvibratoa,x
  1192 37F3 79 1C 32					adc vib0,y
  1193 						EIF
  1194 37F6 9D 88 30				sta trackn_shiftfrq,x
  1195 						IFT FEAT_EFFECTVIBRATO
  1196 37F9 B9 31 32					lda vibtabnext,y
  1197 37FC 9D 10 31					sta trackn_effvibratoa,x
  1198 						EIF
  1199 37FF 4C 05 38				jmp ei2
  1200 3802			ei1
  1201 3802 DE 08 31				dec trackn_effdelay,x
  1202 3805			ei2
  1203 					EIF
  1204 3805 BC 40 31			ldy trackn_tableend,x
  1205 3808 C0 0D			cpy #INSTRPAR+1
  1206 380A 90 3C			bcc ei3
  1207 380C BD 50 31			lda trackn_tablespeeda,x
  1208 380F 10 31			bpl ei2f
  1209 3811			ei2c
  1210 3811 98				tya
  1211 3812 DD 38 31			cmp trackn_tablea,x
  1212 3815 D0 08			bne ei2c2
  1213 					IFT FEAT_TABLEGO
  1214 3817 BD 48 31				lda trackn_tablelop,x
  1215 					ELS
  1216 						lda #INSTRPAR
  1217 					EIF
  1218 381A 9D 38 31			sta trackn_tablea,x
  1219 381D D0 03			bne ei2a
  1220 381F			ei2c2
  1221 381F FE 38 31			inc trackn_tablea,x
  1222 3822			ei2a
  1223 3822 BD C0 30			lda trackn_instrdb,x
  1224 3825 85 D7			sta nt
  1225 3827 BD C8 30			lda trackn_instrhb,x
  1226 382A 85 D8			sta nt+1
  1227 382C BC 38 31			ldy trackn_tablea,x
  1228 382F B1 D7			lda (nt),y
  1229 					IFT FEAT_TABLEMODE
  1230 3831 BC 28 31				ldy trackn_tablemode,x
  1231 3834 F0 04				beq ei2e
  1232 3836 18					clc
  1233 3837 7D 30 31				adc trackn_tablenote,x
  1234 383A			ei2e
  1235 					EIF
  1236 383A 9D 30 31			sta trackn_tablenote,x
  1237 383D BD 20 31			lda trackn_tabletypespeed,x
  1238 					IFT FEAT_TABLETYPE||FEAT_TABLEMODE
  1239 3840 29 3F				and #$3f
  1240 					EIF
  1241 3842			ei2f
  1242 3842 38				sec
  1243 3843 E9 01			sbc #1
  1244 3845 9D 50 31			sta trackn_tablespeeda,x
  1245 3848			ei3
  1246 3848 BD E8 30			lda trackn_instrreachend,x
  1247 384B 10 1F			bpl ei4
  1248 384D BD 68 30			lda trackn_volume,x
  1249 3850 F0 1A			beq ei4
  1250 					IFT FEAT_VOLUMEMIN
  1251 3852 DD 00 31				cmp trackn_volumemin,x
  1252 3855 F0 15				beq ei4
  1253 3857 90 13				bcc ei4
  1254 					EIF
  1255 3859 A8				tay
  1256 385A BD F8 30			lda trackn_volumeslidevalue,x
  1257 385D 18				clc
  1258 385E 7D F0 30			adc trackn_volumeslidedepth,x
  1259 3861 9D F8 30			sta trackn_volumeslidevalue,x
  1260 3864 90 06			bcc ei4
  1261 3866 98				tya
  1262 3867 E9 10			sbc #16
  1263 3869 9D 68 30			sta trackn_volume,x
  1264 386C			ei4
  1265 					IFT FEAT_COMMAND2
  1266 386C A9 00				lda #0
  1267 386E 85 DD				sta frqaddcmd2
  1268 					EIF
  1269 					IFT FEAT_COMMAND1||FEAT_COMMAND2||FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
  1270 3870 A5 DA				lda reg2
  1271 3872 29 70				and #$70
  1272 						IFT 1==[FEAT_COMMAND1+FEAT_COMMAND2+FEAT_COMMAND3+FEAT_COMMAND4+FEAT_COMMAND5+FEAT_COMMAND6+FEAT_COMMAND7]	
  1273 							beq cmd0	
  1274 						ELS
  1275 3874 4A						lsr @
  1276 3875 4A						lsr @
  1277 3876 8D 7A 38					sta jmx+1
  1278 3879 90 FE		jmx			bcc *
  1279 387B 4C 72 39					jmp cmd0
  1280 387E EA						nop
  1281 387F 4C 9A 38					jmp cmd1
  1282 							IFT FEAT_COMMAND2||FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
  1283 3882 EA							nop
  1284 3883 4C 9F 38						jmp cmd2
  1285 							EIF
  1286 							IFT FEAT_COMMAND3||FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
  1287 3886 EA							nop
  1288 3887 4C A9 38						jmp cmd3
  1289 							EIF
  1290 							IFT FEAT_COMMAND4||FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
  1291 388A EA							nop
  1292 388B 4C B5 38						jmp cmd4
  1293 							EIF
  1294 							IFT FEAT_COMMAND5||FEAT_COMMAND6||FEAT_COMMAND7	
  1295 388E EA							nop
  1296 388F 4C C4 38						jmp cmd5
  1297 							EIF
  1298 							IFT FEAT_COMMAND6||FEAT_COMMAND7 
  1299 3892 EA							nop
  1300 3893 4C 37 39						jmp cmd6
  1301 							EIF
  1302 							IFT FEAT_COMMAND7 
  1303 3896 EA							nop
  1304 3897 4C 42 39						jmp cmd7
  1305 							EIF
  1306 						EIF
  1307 					EIF
  1308 					
  1309 				;* end of instruments effects code...
  1310 					
  1311 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1312
  1313 				;* start of instruments commands code... this is a direct followup of the instruments effects code.
  1314 					
  1315 389A			cmd1
  1316 					IFT FEAT_COMMAND1
  1317 389A A5 DB				lda reg3
  1318 						IFT FEAT_PORTAMENTO
  1319 389C 4C E1 3A					jmp pp10d		; fixes Portamento overwriting the CMD1 command (absolute pitch) 
  1320 						ELS
  1321 							jmp cmd0c
  1322 						EIF
  1323 					EIF
  1324 389F			cmd2
  1325 					IFT FEAT_COMMAND2
  1326 389F A5 DB				lda reg3
  1327 38A1 85 DD				sta frqaddcmd2
  1328 38A3 BD 60 30				lda trackn_note,x
  1329 38A6 4C 78 39				jmp cmd0a
  1330 					EIF
  1331 38A9			cmd3
  1332 					IFT FEAT_COMMAND3
  1333 38A9 BD 60 30				lda trackn_note,x
  1334 38AC 18					clc
  1335 38AD 65 DB				adc reg3
  1336 38AF 9D 60 30				sta trackn_note,x
  1337 38B2 4C 78 39				jmp cmd0a
  1338 					EIF
  1339 38B5			cmd4
  1340 					IFT FEAT_COMMAND4
  1341 38B5 BD 88 30				lda trackn_shiftfrq,x
  1342 38B8 18					clc
  1343 38B9 65 DB				adc reg3
  1344 38BB 9D 88 30				sta trackn_shiftfrq,x
  1345 38BE BD 60 30				lda trackn_note,x
  1346 38C1 4C 78 39				jmp cmd0a
  1347 					EIF
  1348 38C4			cmd5
  1349 					IFT FEAT_COMMAND5&&FEAT_PORTAMENTO
  1350 						IFT FEAT_TABLETYPE
  1351 38C4 BD 20 31					lda trackn_tabletypespeed,x		; table type? 
  1352 38C7 10 26					bpl cmd5a1						; positive is notes table mode
  1353 38C9 BC 60 30					ldy trackn_note,x				; current note
  1354 						
  1355 							IFT FEAT_FULL_16BIT||FEAT_BASS16
  1356 38CC A5 D9						lda reg1					; flag in memory
  1357 38CE 10 04						bpl cmd5a0					; positive means no 16-bit mode active
  1358 38D0 98							tya 
  1359 38D1 0A							asl @						; offset for the 16-bit addressing
  1360 38D2 A8							tay
  1361 38D3 C8							iny							; 16-bit MSB offset
  1362 							EIF
  1363
  1364 38D4			cmd5a0
  1365 				;			lda (nr),y						; actual note from table
  1366 				;			clc								; clear carry flag	
  1367 				;			adc trackn_tablenote,x			; frequency from table-- FIXME: might overflow!
  1368
  1369 38D4 B1 D5					lda (nr),y						; this is the actual note base frequency, or AUDF 
  1370 38D6 18						clc								; clear carry 
  1371 38D7 10 0B					bpl cmd5a0b						; if the value is positive, branch and finish there
  1372 38D9			cmd5a0a
  1373 38D9 7D 30 31					adc trackn_tablenote,x
  1374 38DC 70 29					bvs cmd5ax
  1375 38DE 30 27					bmi cmd5ax
  1376 38E0 A9 FF					lda #$FF						; if overflow, force #$FF!
  1377 38E2 D0 23					bne cmd5ax
  1378 38E4			cmd5a0b
  1379 38E4 7D 30 31					adc trackn_tablenote,x
  1380 38E7 70 1E					bvs cmd5ax
  1381 38E9 10 1C					bpl cmd5ax
  1382 38EB A9 00					lda #0					; if overflow, force #$00! 
  1383 38ED F0 18					beq cmd5ax
  1384 				;			jmp cmd5ax				; process the remaining of the code there
  1385 						EIF
  1386 					
  1387 38EF			cmd5a1
  1388 38EF BD 60 30				lda trackn_note,x			; current note
  1389 38F2 18					clc					; clear carry
  1390 38F3 7D 30 31				adc trackn_tablenote,x			; add the note from table
  1391 38F6 C9 3D				cmp #61					; max possible note 
  1392 38F8 90 02				bcc cmd5a2				; branch if lower than 61, finish with it 
  1393 38FA A9 3F				lda #63					; else, max possible note value
  1394 38FC			cmd5a2
  1395 38FC A8					tay
  1396 					
  1397 						IFT FEAT_FULL_16BIT||FEAT_BASS16	;* TODO: fix the proper 16-bit mode, as well as the Sawtooth and/or AUTOFILTER when combined as well
  1398 38FD A5 D9					lda reg1				; flag in memory
  1399 38FF 10 04					bpl cmd5a3				; positive means no 16-bit mode active
  1400 3901 98						tya 
  1401 3902 0A						asl @					; offset for the 16-bit addressing
  1402 3903 A8						tay
  1403 3904 C8						iny					; 16-bit MSB offset
  1404 						EIF
  1405
  1406 3905			cmd5a3	
  1407 3905 B1 D5				lda (nr),y				; actual note from table
  1408 3907			cmd5ax
  1409 3907 9D 90 30				sta trackn_portafrqc,x			; set the target portamento frequency
  1410 390A A4 DB				ldy reg3				; #$XY instrument parameter
  1411 390C D0 03				bne cmd5a				; jump aheead if not zero 
  1412 390E 9D 98 30				sta trackn_portafrqa,x			; else, set the current portamento pitch instantly
  1413 						;* BUG: Portamento is never initialised if the #$XY parameter is not on the very first player call! 
  1414 3911			cmd5a
  1415 3911 BD 98 30				lda trackn_portafrqa,x			; is the current frequency set to 0?
  1416 3914 D0 09				bne cmd5b				; if not, it's most likely correctly set
  1417 3916 A8					tay					; force the #$XY parameter to 0 to force Portamento to not run 
  1418 3917 85 DB				sta reg3				; it will be called again further below
  1419 3919 BD 90 30				lda trackn_portafrqc,x			; target frequency previously set
  1420 391C 9D 98 30				sta trackn_portafrqa,x			; overwrite forced on the current frequency, to avoid the "pitch from 0" bug
  1421 391F			cmd5b
  1422 391F 98					tya					; transfer the #$XY parameter to the accumulator
  1423 3920 4A					lsr @					; divide by 16
  1424 3921 4A					lsr @
  1425 3922 4A					lsr @
  1426 3923 4A					lsr @
  1427 3924 9D A0 30				sta trackn_portaspeed,x			; set the portamento speed with the new value
  1428 3927 9D A8 30				sta trackn_portaspeeda,x
  1429 392A A5 DB				lda reg3				; #$XY parameter again
  1430 392C 29 0F				and #$0f				; Only keep the Y values
  1431 392E 9D B0 30				sta trackn_portadepth,x			; set the portamento pitch offset to process each step
  1432 3931 BD 60 30				lda trackn_note,x			; current note
  1433 3934 4C 78 39				jmp cmd0a				; finish everything else like normal from there
  1434 					ELI FEAT_COMMAND5
  1435 						lda trackn_note,x
  1436 						jmp cmd0a
  1437 					EIF
  1438
  1439 3937			cmd6
  1440 					IFT FEAT_COMMAND6&&FEAT_FILTER		;* EXPERIMENTAL: do NOT stack the effects together, and start the offset at 0!
  1441 3937 A5 DB				lda reg3				; $XY parameter for the effect command
  1442 				;		clc					; clear the carry flag
  1443 				;		adc trackn_filter,x			; add it to the frequency offset currently in memory	
  1444 3939 9D 58 31				sta trackn_filter,x			; overwrite the frequency offset with the new value 
  1445 393C BD 60 30				lda trackn_note,x			; current note for this instrument
  1446 393F 4C 78 39				jmp cmd0a				; process the remaining of CMD0 without adding the $XY value to it 
  1447 					ELI FEAT_COMMAND6			; CMD6 alone is essentially no command at all, regardless of the $XY value
  1448 						lda trackn_note,x			; current note for this instrument
  1449 						jmp cmd0a				; process the remaining of CMD0 without adding the $XY value to it 
  1450 					EIF
  1451
  1452 3942			cmd7
  1453 					IFT FEAT_COMMAND7
  1454 						IFT FEAT_TWO_TONE||FEAT_VOLUME_ONLY
  1455 							IFT FEAT_TWO_TONE
  1456 3942 A5 DB						lda reg3
  1457 3944 C9 FD						cmp #$FD		; #$FD toggles Two-Tone off
  1458 3946 90 1A						bcc cmd7f		; no values will match if less than this, failsafe in case the BPL above didn't catch it
  1459 3948 F0 06						beq cmd7b		; turn off the Two-Tone Filter if equal
  1460 394A C9 FE						cmp #$FE		; #$FE toggles Two-Tone on
  1461 394C F0 06						beq cmd7c		; turn on the Two-Tone Filter if equal
  1462 								IFT FEAT_VOLUME_ONLY	
  1463 394E D0 18							bne cmd7a		; #$FF sets volume only mode, and will always be that value here, unconditional branching
  1464 								ELS
  1465 									bne cmd7f		; skip ahead, and don't set volume only mode either
  1466 								EIF
  1467 3950			cmd7b				
  1468 3950 A9 03						lda #3			; disable the Two-Tone Filter with this value
  1469 3952 D0 02						bne cmd7d		; unconditional
  1470 3954			cmd7c				
  1471 3954 A9 8B						lda #$8B		; enable the Two-Tone Filter with this value
  1472 3956			cmd7d
  1473 								IFT TRACKS>4
  1474 3956 E0 04							cpx #4
  1475 3958 90 05							bcc cmd7e		; less than 4
  1476 395A 8D D5 3C							sta v_skctl2		; SKCTL, Right POKEY 
  1477 395D B0 03							bcs cmd7f		; carry flag still set, unconditional
  1478 								EIF
  1479 395F			cmd7e
  1480 395F 8D D3 3C						sta v_skctl		; SKCTL, Left POKEY
  1481 							ELS
  1482 								IFT FEAT_VOLUME_ONLY	
  1483 									lda reg3
  1484 									cmp #$FF
  1485 									beq cmd7a		; set volume only mode if equal
  1486 								EIF
  1487 							EIF
  1488 3962			cmd7f
  1489 3962 BD 60 30					lda trackn_note,x	; this is the expected variable in memory
  1490 3965 4C 78 39					jmp cmd0a 
  1491 3968			cmd7a
  1492 							IFT FEAT_VOLUME_ONLY
  1493 3968 BD 80 31						lda trackn_audc,x
  1494 396B 09 F0						ora #$f0
  1495 396D 9D 80 31						sta trackn_audc,x
  1496 3970 D0 F0						bne cmd7f		; unconditional
  1497 							EIF
  1498 						ELS
  1499 							lda trackn_note,x	; this is the expected variable in memory
  1500 							jmp cmd0a 
  1501 						EIF
  1502 					EIF
  1503 					
  1504 3972			cmd0
  1505 3972 BD 60 30			lda trackn_note,x
  1506 3975 18				clc
  1507 3976 65 DB			adc reg3
  1508 3978			cmd0a
  1509 					IFT FEAT_TABLETYPE
  1510 3978 BC 20 31				ldy trackn_tabletypespeed,x
  1511 397B 30 7F				bmi cmd0b
  1512 					EIF
  1513 397D 18				clc
  1514 397E 7D 30 31			adc trackn_tablenote,x
  1515 3981 C9 3D			cmp #61
  1516 3983 90 07			bcc cmd0a1
  1517 3985 A9 00			lda #0
  1518 3987 9D 80 31			sta trackn_audc,x
  1519 398A A9 3F			lda #63
  1520 398C			cmd0a1
  1521 398C A8				tay
  1522 					
  1523 398D			cmd0a1_a 	
  1524 					IFT FEAT_FULL_16BIT||FEAT_BASS16
  1525 398D A5 D9				lda reg1
  1526 398F F0 49				beq cmd0a3		; no 16-bit flag set
  1527 3991 10 34				bpl cmd0a2		; Sawtooth flag set (maybe) 
  1528 3993 98					tya
  1529 3994 0A					asl @			; offset for the 16-bit addressing!!!
  1530 3995 A8					tay
  1531 3996 C8					iny			; offset to load the MSB value first
  1532 3997 B1 D5				lda (nr),y
  1533 3999 88					dey			; offset to load the LSB value later
  1534 399A 9D 78 31				sta trackn_audf,x	; get and store the MSB channel early
  1535 399D BD 88 30				lda trackn_shiftfrq,x
  1536 						IFT FEAT_COMMAND2
  1537 39A0 18						clc
  1538 39A1 65 DD					adc frqaddcmd2
  1539 						EIF
  1540 39A3 85 DC				sta tmp			; get and store the frequency shift early, combined if CMD2 is also enabled
  1541 39A5 30 10				bmi cmd0a1sub		; will subtract 1 from the MSB if negative on overflow
  1542 39A7			cmd0a1add
  1543 39A7 B1 D5				lda (nr),y
  1544 39A9 18					clc
  1545 39AA 65 DC				adc tmp
  1546 39AC 9D 5F 31				sta trackn_bass16-1,x	; LSB channel
  1547 39AF 90 03				bcc cmd0a1adddone	; no overflow, done
  1548 39B1 FE 78 31				inc trackn_audf,x	; increment the MSB if the value went past #$FF
  1549 39B4			cmd0a1adddone	
  1550 39B4 4C 84 3A				jmp pp9			; done
  1551 						
  1552 39B7			cmd0a1sub
  1553 39B7 B1 D5				lda (nr),y
  1554 39B9 18					clc
  1555 39BA 65 DC				adc tmp
  1556 39BC 9D 5F 31				sta trackn_bass16-1,x	; LSB channel
  1557 39BF B0 F3				bcs cmd0a1adddone	; no overflow, done
  1558 39C1 DE 78 31				dec trackn_audf,x	; decrement the MSB if the value went past #$00
  1559 						
  1560 39C4			cmd0a1subdone	
  1561 39C4 4C 84 3A				jmp pp9			; done	
  1562 					EIF
  1563 					
  1564 39C7			cmd0a2	;* Sawtooth is so unlikely to even range the low #$FF frequencies that applying the vibrato fixes is pointless!
  1565 					IFT FEAT_FULL_SAWTOOTH&&FEAT_AUDCTLMANUALSET
  1566 39C7 C9 41				cmp #$41		; 1.79mhz => Sawtooth?
  1567 39C9 D0 0F				bne cmd0a3		; no Sawtooth for sure
  1568 39CB B1 D5				lda (nr),y
  1569 39CD 18					clc
  1570 39CE 7D 88 30				adc trackn_shiftfrq,x
  1571 						IFT FEAT_COMMAND2
  1572 39D1 18						clc
  1573 39D2 65 DD					adc frqaddcmd2
  1574 						EIF	
  1575 39D4 9D 7A 31				sta trackn_audf+2,x	; since we're in channel 1 of either POKEY, offset +2 will always be the 3rd channel
  1576 39D7 68					pla			; get the second sawtooth pointer back from stack
  1577 39D8 85 D5				sta nr			; update the tables pointer to the other sawtooth table
  1578 					EIF
  1579
  1580 39DA			cmd0a3
  1581 				;	lda (nr),y
  1582 				;	clc
  1583 				;	adc trackn_shiftfrq,x 
  1584 				;	IFT FEAT_COMMAND2
  1585 				;	clc
  1586 				;	adc frqaddcmd2
  1587 				;	EIF
  1588
  1589 39DA BD 88 30			lda trackn_shiftfrq,x	; vibrato, and some other shifts use this value 
  1590 					IFT FEAT_COMMAND2 
  1591 39DD 18					clc			; clear carry 
  1592 39DE 65 DD				adc frqaddcmd2		; if the CMD2 feature is also enabled, add that value as well 
  1593 					EIF 
  1594 39E0 85 DC			sta tmp			; temporary, for faster operation below
  1595 39E2			cmd0a3a
  1596 39E2 B1 D5			lda (nr),y		; this is the actual note base frequency, or AUDF 
  1597 39E4 18				clc			; clear carry 
  1598 39E5 10 0A			bpl cmd0a3c		; if the value is positive, branch and finish there
  1599 39E7			cmd0a3b
  1600 39E7 65 DC			adc tmp
  1601 39E9 70 0E			bvs cmd0a4
  1602 39EB 30 0C			bmi cmd0a4
  1603 39ED A9 FF			lda #$FF		; if overflow, force #$FF!
  1604 39EF D0 08			bne cmd0a4
  1605 39F1			cmd0a3c
  1606 39F1 65 DC			adc tmp
  1607 39F3 70 04			bvs cmd0a4
  1608 39F5 10 02			bpl cmd0a4
  1609 39F7 A9 00			lda #0			; if overflow, force #$00!
  1610 39F9			cmd0a4 
  1611
  1612 					IFT FEAT_TABLETYPE
  1613 39F9 4C 81 3A			jmp cmd0c
  1614 39FC			cmd0b
  1615 39FC C9 3D			cmp #61
  1616 39FE 90 07			bcc cmd0b1
  1617 3A00 A9 00			lda #0
  1618 3A02 9D 80 31			sta trackn_audc,x
  1619 3A05 A9 3F			lda #63
  1620 3A07			cmd0b1
  1621 3A07 A8				tay
  1622
  1623 3A08			cmd0b1_a 
  1624 					IFT FEAT_FULL_16BIT||FEAT_BASS16
  1625 3A08 A5 D9				lda reg1 
  1626 3A0A F0 52				beq cmd0b3		; no 16-bit flag set
  1627 3A0C 10 39				bpl cmd0b2		; Sawtooth flag set (maybe) 
  1628 3A0E 98					tya
  1629 3A0F 0A					asl @			; offset for the 16-bit addressing!!!
  1630 3A10 A8					tay
  1631 3A11 C8					iny			; offset to load the MSB value first
  1632 3A12 B1 D5				lda (nr),y
  1633 3A14 88					dey			; offset to load the LSB value later
  1634 3A15 9D 78 31				sta trackn_audf,x	; get and store the MSB channel early
  1635 3A18 BD 88 30				lda trackn_shiftfrq,x
  1636 3A1B 18					clc
  1637 3A1C 7D 30 31				adc trackn_tablenote,x
  1638 3A1F 18					clc
  1639 						IFT FEAT_COMMAND2
  1640 3A20 18						clc
  1641 3A21 65 DD					adc frqaddcmd2
  1642 						EIF
  1643 3A23 85 DC				sta tmp			; get and store the frequency shift early, combined if CMD2 is also enabled
  1644 3A25 30 10				bmi cmd0b1sub		; will subtract 1 from the MSB if negative on overflow
  1645 3A27			cmd0b1add
  1646 3A27 B1 D5				lda (nr),y
  1647 3A29 18					clc
  1648 3A2A 65 DC				adc tmp
  1649 3A2C 9D 5F 31				sta trackn_bass16-1,x	; LSB 16-bit channel, update early here
  1650 3A2F 90 03				bcc cmd0b1adddone	; no overflow, done
  1651 3A31 FE 78 31				inc trackn_audf,x	; increment the MSB if the value went past #$FF
  1652 3A34			cmd0b1adddone	
  1653 3A34 4C 84 3A				jmp pp9			; done
  1654 3A37			cmd0b1sub
  1655 3A37 B1 D5				lda (nr),y
  1656 3A39 18					clc
  1657 3A3A 65 DC				adc tmp
  1658 3A3C 9D 5F 31				sta trackn_bass16-1,x	; LSB 16-bit channel, update early here
  1659 3A3F B0 F3				bcs cmd0b1adddone	; no overflow, done
  1660 3A41 DE 78 31				dec trackn_audf,x	; decrement the MSB if the value went past #$00
  1661 3A44			cmd0b1subdone	
  1662 3A44 4C 84 3A				jmp pp9			; done 	
  1663 					EIF
  1664 					
  1665 3A47			cmd0b2	;* Sawtooth is so unlikely to even range the low #$FF frequencies that applying the vibrato fixes is pointless!
  1666 					IFT FEAT_FULL_SAWTOOTH&&FEAT_AUDCTLMANUALSET
  1667 3A47 C9 41				cmp #$41					; 1.79mhz => Sawtooth?
  1668 3A49 D0 13				bne cmd0b3					; no Sawtooth for sure 
  1669 3A4B BD 88 30				lda trackn_shiftfrq,x
  1670 3A4E 18					clc
  1671 3A4F 7D 30 31				adc trackn_tablenote,x
  1672 3A52 18					clc
  1673 3A53 71 D5				adc (nr),y	
  1674 						IFT FEAT_COMMAND2
  1675 3A55 18						clc
  1676 3A56 65 DD					adc frqaddcmd2
  1677 						EIF	
  1678 3A58 9D 7A 31				sta trackn_audf+2,x			; since we're in channel 1 of either POKEY, offset +2 will always be the 3rd channel
  1679 3A5B 68					pla							; get the second sawtooth pointer back from stack
  1680 3A5C 85 D5				sta nr						; update the tables pointer to the other sawtooth table
  1681 					EIF
  1682
  1683 3A5E			cmd0b3
  1684 				;	lda trackn_shiftfrq,x
  1685 				;	clc
  1686 				;	adc trackn_tablenote,x
  1687 				;	clc
  1688 				;	adc (nr),y
  1689 				;	IFT FEAT_COMMAND2
  1690 				;	clc
  1691 				;	adc frqaddcmd2
  1692 				;	EIF
  1693
  1694 3A5E BD 88 30			lda trackn_shiftfrq,x			; vibrato, and some other shifts use this value 
  1695 3A61 18				clc								; clear carry 
  1696 3A62 7D 30 31			adc trackn_tablenote,x			; freq table
  1697 					IFT FEAT_COMMAND2 
  1698 3A65 18					clc							; clear carry 
  1699 3A66 65 DD				adc frqaddcmd2				; if the CMD2 feature is also enabled, add that value as well 
  1700 					EIF 
  1701 3A68 85 DC			sta tmp							; temporary, for faster operation below
  1702 3A6A			cmd0b3a
  1703 3A6A B1 D5			lda (nr),y						; this is the actual note base frequency, or AUDF 
  1704 3A6C 18				clc								; clear carry 
  1705 3A6D 10 0A			bpl cmd0b3c						; if the value is positive, branch and finish there
  1706 3A6F			cmd0b3b
  1707 3A6F 65 DC			adc tmp
  1708 3A71 70 0E			bvs cmd0c
  1709 3A73 30 0C			bmi cmd0c
  1710 3A75 A9 FF			lda #$FF						; if overflow, force #$FF!
  1711 3A77 D0 08			bne cmd0c
  1712 3A79			cmd0b3c
  1713 3A79 65 DC			adc tmp
  1714 3A7B 70 04			bvs cmd0c
  1715 3A7D 10 02			bpl cmd0c
  1716 3A7F A9 00			lda #0							; if overflow, force #$00! 
  1717
  1718 					EIF
  1719 					
  1720 3A81			cmd0c
  1721 3A81 9D 78 31			sta trackn_audf,x
  1722 					
  1723 				;* end of instruments commands code... 
  1724 					
  1725 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1726 					
  1727 				;* start of Portamento code... This is currently not properly compatible with 16-bit mode or Sawtooth, unfortunately.
  1728 				;* TODO: fix Portamento for things that use combined channels to run
  1729 				;* UPDATE: starting to understand a bit more how Portamento is working in the code...
  1730 				;* POTENTIAL IMPROVEMENT: process the command in a different order? Add CMD2 pitch, and Vibrato Fix?
  1731 				;* Maybe even set a flag to make sure the "reached" pitch clears the portamento mode? 
  1732 				;* That way, it won't try to process it infinitely and possibly output incorrect pitch...
  1733 					
  1734 3A84			pp9
  1735 					IFT FEAT_PORTAMENTO
  1736 3A84 BD A8 30				lda trackn_portaspeeda,x	; is the portamento effect curently active?
  1737 3A87 F0 32				beq pp10					; it will be skipped if equal 
  1738 3A89 DE A8 30				dec trackn_portaspeeda,x	; decrease the value by 1
  1739 3A8C D0 2D				bne pp10					; then jump ahead if it is not 0
  1740 3A8E BD A0 30				lda trackn_portaspeed,x		; portamento speed in memory
  1741 3A91 9D A8 30				sta trackn_portaspeeda,x	; overwrite the current portamento speed value to reset it
  1742 3A94 BD 98 30				lda trackn_portafrqa,x		; current portamento frequency in memory
  1743 3A97 DD 90 30				cmp trackn_portafrqc,x		; compare to target frequency
  1744 3A9A F0 1F				beq pp10					; if equal, portamento is done and can be skipped
  1745 3A9C B0 0D				bcs pps1					; if the current portamento pitch is higher, branch here
  1746 					
  1747 3A9E			pps0 ; else, it is below the target pitch here
  1748 3A9E 7D B0 30				adc trackn_portadepth,x		; add the portamento frequency offset to it
  1749 3AA1 B0 12				bcs pps8					; overflown? branch if the carry flag is set
  1750 3AA3 DD 90 30				cmp trackn_portafrqc,x		; compare to the target frequency
  1751 3AA6 B0 0D				bcs pps8					; equal or above means it was reached
  1752 3AA8 4C B8 3A				jmp pps9					; otherwise, it is still not reached yet
  1753 					
  1754 3AAB			pps1 ; current pitch is higher than the target pitch here
  1755 3AAB FD B0 30				sbc trackn_portadepth,x		; subtract the portamento frequency offset from it
  1756 3AAE 90 05				bcc pps8					; overflown? branch if the carry flag is clear
  1757 3AB0 DD 90 30				cmp trackn_portafrqc,x		; compare to the target frequency
  1758 3AB3 B0 03				bcs pps9					; equal or above means it was not yet reached
  1759 3AB5			pps8
  1760 3AB5 BD 90 30				lda trackn_portafrqc,x		; the target pitch was reached, load it in memory
  1761 3AB8			pps9
  1762 3AB8 9D 98 30				sta trackn_portafrqa,x		; update the current portamento pitch with the new pitch
  1763 3ABB			pp10
  1764 3ABB A5 DA				lda reg2					; instrument commands and distortion
  1765 3ABD 29 01				and #$01					; Portamento bit
  1766 3ABF F0 23				beq pp11					; if 0 it is not set and will be skipped
  1767 					
  1768 3AC1			pp10a
  1769 				;		lda trackn_portafrqa,x		; load the current portamento frequency in memory
  1770 				;		clc							; clear the carry flag 
  1771 				;		adc trackn_shiftfrq,x		; add to it the shiftfrq/vibrato pitch
  1772
  1773 					;* TODO: add support for CMD2 offset, and fix vibrato when TableFreq is also involved, they have been ignored here!
  1774 					;* looks like the CMD0, and CMD1 were also ignored??? but why? 
  1775 					;* seems like the Table of Freqs mode is broken? Adding Negative values	
  1776
  1777 3AC1 BD 88 30				lda trackn_shiftfrq,x		; vibrato, and some other shifts use this value 
  1778 						IFT FEAT_COMMAND2 
  1779 3AC4 18						clc						; clear carry 
  1780 3AC5 65 DD					adc frqaddcmd2			; if the CMD2 feature is also enabled, add that value as well 
  1781 						EIF 
  1782 3AC7 85 DC				sta tmp						; temporary, for faster operation below
  1783 3AC9 BD 98 30				lda trackn_portafrqa,x		; load the current portamento frequency in memory
  1784 3ACC 18					clc							; clear the carry flag	
  1785 3ACD 10 0A				bpl pp10c 					; positive value is outside of the dangerous range and can be processed
  1786 3ACF			pp10b
  1787 3ACF 65 DC				adc tmp
  1788 3AD1 70 0E				bvs pp10d
  1789 3AD3 30 0C				bmi pp10d
  1790 3AD5 A9 FF				lda #$FF					; if overflow, force #$FF!
  1791 3AD7 D0 08				bne pp10d
  1792 3AD9			pp10c
  1793 3AD9 65 DC				adc tmp
  1794 3ADB 70 04				bvs pp10d
  1795 3ADD 10 02				bpl pp10d
  1796 3ADF A9 00				lda #0						; if overflow, force #$00! 
  1797 					
  1798 3AE1			pp10d
  1799 3AE1 9D 78 31				sta trackn_audf,x			; update the channel AUDF with the new value if Portamento was processed 
  1800 3AE4			pp11
  1801 					EIF
  1802
  1803 				;* end of Portamento code...
  1804
  1805 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1806 					
  1807 				;* part of mainloop code... this is an extra step added for the purpose of clearning the memory from 16-bit or Sawtooth addresses when unused.
  1808 					
  1809 3AE4			ppnext
  1810 3AE4 CA				dex
  1811 3AE5 30 03			bmi rmt_p4
  1812 3AE7 4C 1B 37			jmp pp1
  1813 3AEA			rmt_p4
  1814 3AEA A0 00			ldy #0					; will be used to mute channels and reset the flags
  1815
  1816 				;* end of mainloop code... everything below will be conditionally assembled for easy optimisation.
  1817
  1818 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1819
  1820 				;* start of 16-bit flag code... a much more stripped down version
  1821 				;* TODO: implement in a much more efficient way...
  1822 				;* BUG? LSB channels need to be reset to process certain commands properly? That doesn't sound right...
  1823
  1824 				;* UPDATE: this entire block may not even be necessary after all! 
  1825 				;* It could be moved right in the channels index bit right where the initial flag check is done!
  1826 				;* UPDATE2: nevermind, this might fail on empty instrument channels, so better keep it here... 
  1827
  1828 					IFT FEAT_FULL_16BIT||FEAT_BASS16	;****
  1829 3AEC			bb1	
  1830 3AEC AD 69 31				lda g_flag+1
  1831 3AEF 10 06				bpl bb2						; not 16-bit flag, do nothing here	
  1832 3AF1 AD 60 31				lda trackn_bass16+0			; ch1
  1833 3AF4 8D 78 31				sta trackn_audf+0
  1834 3AF7			bb2
  1835 3AF7 AD 6B 31				lda g_flag+3
  1836 3AFA 10 06				bpl bb3						; not 16-bit flag, do nothing here
  1837 3AFC AD 62 31				lda trackn_bass16+2			; ch3
  1838 3AFF 8D 7A 31				sta trackn_audf+2
  1839 3B02			bb3
  1840 3B02 8C 60 31				sty trackn_bass16+0
  1841 3B05 8C 62 31				sty trackn_bass16+2
  1842 					
  1843 						IFT STEREOMODE==1
  1844 3B08			bs1	
  1845 3B08 AD 6D 31					lda g_flag+1+4
  1846 3B0B 10 06					bpl bs2					; not 16-bit flag, do nothing here	
  1847 3B0D AD 64 31					lda trackn_bass16+0+4	; ch1
  1848 3B10 8D 7C 31					sta trackn_audf+0+4
  1849 3B13			bs2
  1850 3B13 AD 6F 31					lda g_flag+3+4
  1851 3B16 10 06					bpl bs3					; not 16-bit flag, do nothing here
  1852 3B18 AD 66 31					lda trackn_bass16+2+4	; ch3
  1853 3B1B 8D 7E 31					sta trackn_audf+2+4
  1854 3B1E			bs3
  1855 3B1E 8C 64 31					sty trackn_bass16+0+4
  1856 3B21 8C 66 31					sty trackn_bass16+2+4
  1857 						EIF
  1858 					EIF					;****
  1859
  1860 				;* end of 16-bit flag code...
  1861 					
  1862 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  1863
  1864 				;* start of Autofilter code... a much more stripped down version
  1865 				;* TODO: redesign the implementation to allow a much more precise manipulation to be achieved
  1866 				;* UPDATE: an attempt to mitigate overflows has been done here... 
  1867
  1868 					IFT FEAT_FILTER 
  1869 3B24 AE 69 3C				ldx v_audctl 
  1870 3B27			qq1
  1871 						IFT FEAT_FILTERG0L
  1872 3B27 AD 78 30					lda trackn_command+0		; AUTOFILTER command set? BIT7 == #$80
  1873 3B2A 10 29					bpl qq2				; if the value is positive, the command is not set, skip
  1874 3B2C AD 80 31					lda trackn_audc+0		; AUDC value from ch1 currently in memory
  1875 3B2F 29 0F					and #$0f			; only keep the volume value from the byte
  1876 3B31 F0 22					beq qq2				; if the volume is 0, skip 
  1877 3B33 AD 78 31					lda trackn_audf+0		; AUDF value from ch1 currently in memory 
  1878 3B36 18						clc				; clear the carry flag
  1879 3B37 10 0F					bpl qq1a			; it's alright! carry on if the value is in the positive range
  1880 3B39 85 DC					sta tmp				; quick backup first
  1881 3B3B 6D 58 31					adc trackn_filter+0		; add the frequency offset 
  1882 3B3E 30 0B					bmi qq1b			; all good, carry on!
  1883 3B40 A5 DC					lda tmp				; reload the backup value if it had overflown
  1884 3B42 38						sec				; set the carry flag first!
  1885 3B43 ED 58 31					sbc trackn_filter+0		; subtract the frequency offset instead!
  1886 3B46 30 03					bmi qq1b			; finish like normal from here
  1887 3B48			qq1a
  1888 3B48 6D 58 31					adc trackn_filter+0		; add the frequency offset for the AUTOFILTER modulation into the ch1 frequency 
  1889 3B4B			qq1b
  1890 3B4B 8D 7A 31					sta trackn_audf+2		; overwrite the ch3 frequency with the new offset frequency 
  1891 3B4E 8C 58 31					sty trackn_filter+0		; reset that value until a new CMD6 overwrites it
  1892 3B51			qq1c
  1893 3B51 8A						txa				; get the AUDCTL into the accumulator
  1894 3B52 09 04					ora #4				; set the High Pass Filter Ch1+3 bit into it
  1895 3B54 AA						tax				; tramsfer back into X to process the next channel the exact same way
  1896 						EIF
  1897 					
  1898 3B55			qq2
  1899 						IFT FEAT_FILTERG1L
  1900 3B55 AD 79 30					lda trackn_command+1
  1901 3B58 10 29					bpl qq3
  1902 3B5A AD 81 31					lda trackn_audc+1
  1903 3B5D 29 0F					and #$0f
  1904 3B5F F0 22					beq qq3
  1905 3B61 AD 79 31					lda trackn_audf+1
  1906 3B64 18						clc
  1907 3B65 10 0F					bpl qq2a
  1908 3B67 85 DC					sta tmp
  1909 3B69 6D 59 31					adc trackn_filter+1
  1910 3B6C 30 0B					bmi qq2b
  1911 3B6E A5 DC					lda tmp
  1912 3B70 38						sec
  1913 3B71 ED 59 31					sbc trackn_filter+1
  1914 3B74 30 03					bmi qq2b
  1915 3B76			qq2a
  1916 3B76 6D 59 31					adc trackn_filter+1
  1917 3B79			qq2b
  1918 3B79 8D 7B 31					sta trackn_audf+3
  1919 3B7C 8C 59 31					sty trackn_filter+1
  1920 3B7F			qq2c
  1921 3B7F 8A						txa
  1922 3B80 09 02					ora #2
  1923 3B82 AA						tax
  1924 							
  1925 						EIF
  1926 3B83			qq3
  1927 3B83 8E 69 3C				stx v_audctl
  1928 					EIF
  1929
  1930 					IFT FEAT_FILTER&&TRACKS>4
  1931 3B86 AE CB 3C				ldx v_audctl2 
  1932 3B89			qs1
  1933 						IFT FEAT_FILTERG0R
  1934 3B89 AD 7C 30					lda trackn_command+0+4
  1935 3B8C 10 29					bpl qs2
  1936 3B8E AD 84 31					lda trackn_audc+0+4
  1937 3B91 29 0F					and #$0f
  1938 3B93 F0 22					beq qs2
  1939 3B95 AD 7C 31					lda trackn_audf+0+4
  1940 3B98 18						clc
  1941 3B99 10 0F					bpl qs1a
  1942 3B9B 85 DC					sta tmp
  1943 3B9D 6D 5C 31					adc trackn_filter+0+4
  1944 3BA0 30 0B					bmi qs1b
  1945 3BA2 A5 DC					lda tmp
  1946 3BA4 38						sec
  1947 3BA5 ED 5C 31					sbc trackn_filter+0+4
  1948 3BA8 30 03					bmi qs1b
  1949 3BAA			qs1a	
  1950 3BAA 6D 5C 31					adc trackn_filter+0+4
  1951 3BAD			qs1b
  1952 3BAD 8D 7E 31					sta trackn_audf+2+4
  1953 3BB0 8C 5C 31					sty trackn_filter+0+4
  1954 3BB3			qs1c
  1955 3BB3 8A						txa
  1956 3BB4 09 04					ora #4
  1957 3BB6 AA						tax
  1958 						EIF
  1959 3BB7			qs2
  1960 						IFT FEAT_FILTERG1R
  1961 3BB7 AD 7D 30					lda trackn_command+1+4
  1962 3BBA 10 29					bpl qs3
  1963 3BBC AD 85 31					lda trackn_audc+1+4
  1964 3BBF 29 0F					and #$0f
  1965 3BC1 F0 22					beq qs3
  1966 3BC3 AD 7D 31					lda trackn_audf+1+4
  1967 3BC6 18						clc
  1968 3BC7 10 0F					bpl qs2a
  1969 3BC9 85 DC					sta tmp
  1970 3BCB 6D 5D 31					adc trackn_filter+1+4
  1971 3BCE 30 0B					bmi qs2b
  1972 3BD0 A5 DC					lda tmp 
  1973 3BD2 38						sec
  1974 3BD3 ED 5D 31					sbc trackn_filter+1+4
  1975 3BD6 30 03					bmi qs2b 
  1976 3BD8			qs2a
  1977 3BD8 6D 5D 31					adc trackn_filter+1+4
  1978 3BDB			qs2b
  1979 3BDB 8D 7F 31					sta trackn_audf+3+4
  1980 3BDE 8C 5D 31					sty trackn_filter+1+4
  1981 3BE1			qs2c
  1982 3BE1 8A						txa
  1983 3BE2 09 02					ora #2
  1984 3BE4 AA						tax
  1985 						EIF
  1986 3BE5			qs3
  1987 3BE5 8E CB 3C				stx v_audctl2
  1988 					EIF
  1989 					
  1990 				;* end of Autofilter code...
  1991
  1992 				;---------------------------------------------------------------------------------------------------------------------------------------------;	
  1993 					
  1994 				;* end of mainloop code, hit that RTS and that's it!
  1995 					
  1996 3BE8			rmt_p5	
  1997 3BE8 60				rts 
  1998
  1999 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2000
  2001 				;* start of Sawtooth code... there is room for improvements
  2002
  2003 					IFT FEAT_FULL_SAWTOOTH&&FEAT_AUDCTLMANUALSET
  2004 3BE9			do_sawtooth
  2005 						IFT FEAT_FILTER
  2006 3BE9 49 80					eor #$80				; inverts the AUTOFILTER bit, so it does not overwrite things later
  2007 3BEB 9D 78 30					sta trackn_command,x	; overwrite the command byte before the AUTOFILTER code since things where done early
  2008 						EIF
  2009 3BEE A9 64				lda #$64					; high pass filter, CH1+3 + 1.79mhz CH1+3
  2010 						IFT TRACKS>4				; stereo mode
  2011 3BF0 E0 04					cpx #4					; are we in the right POKEY channels?
  2012 3BF2 90 08					bcc do_sawtooth_a 		; if x is lower than 4, we are not
  2013 3BF4 0D CB 3C					ora v_audctl2			; combine the existing AUDCTL value to it
  2014 3BF7 8D CB 3C					sta v_audctl2			; store the new AUDCTL value, right POKEY
  2015 3BFA D0 06					bne do_sawtooth_b 		; unconditional
  2016 						EIF
  2017 3BFC			do_sawtooth_a	
  2018 3BFC 0D 69 3C				ora v_audctl				; combine the existing AUDCTL value to it
  2019 3BFF 8D 69 3C				sta v_audctl				; store the new AUDCTL value, left POKEY
  2020 3C02			do_sawtooth_b
  2021
  2022 						IFT FEAT_COMMAND6			; Sawtooth CMD6 hack... could be optimised much better, or maybe moved into the commands? 
  2023 3C02 A5 DA					lda reg2				; Command and Distortion
  2024 3C04 29 70					and #$70				; keep the Command bits only
  2025 3C06 C9 60					cmp #$60				; CMD6?
  2026 3C08 D0 1C					bne do_sawtooth_c 		; skip if not equal
  2027 3C0A A5 DB					lda reg3				; $XY parameter
  2028 3C0C F0 18					beq do_sawtooth_c 		; skip if the value is 0, nothing will be changed
  2029 3C0E 30 0C					bmi sawtooth_reverse	; negative values (#$80 to #$FF) will reverse the pointers, positive values (#$01 to #$7F) will set the pointers back to normal
  2030 3C10			sawtooth_normal
  2031 3C10 A9 00					lda #<frqtabsawtooth_ch1
  2032 3C12 8D 27 3C					sta saw_ch1
  2033 3C15 A9 40					lda #<frqtabsawtooth_ch3
  2034 3C17 8D 2A 3C					sta saw_ch3	
  2035 3C1A 10 0A					bpl do_sawtooth_c 
  2036 3C1C			sawtooth_reverse
  2037 3C1C A9 40					lda #<frqtabsawtooth_ch3
  2038 3C1E 8D 27 3C					sta saw_ch1
  2039 3C21 A9 00					lda #<frqtabsawtooth_ch1
  2040 3C23 8D 2A 3C					sta saw_ch3
  2041 						EIF
  2042 					
  2043 3C26			do_sawtooth_c
  2044 3C26 A9 00				lda #<frqtabsawtooth_ch1
  2045 = 3C27			saw_ch1	equ *-1	
  2046 3C28 48					pha							; very TEMPORARILY keep the other pointer in the stack
  2047 3C29 A9 40				lda #<frqtabsawtooth_ch3
  2048 = 3C2A			saw_ch3	equ *-1	
  2049 3C2B 85 D5				sta nr
  2050 3C2D E6 D9				inc reg1					; #$40 => #$41, will be necessary later to help differentiate the other flags!
  2051 3C2F			do_sawtooth_d
  2052 3C2F A9 B5				lda #>PAGE_EXTRA_0			; tables MSB pointer, it's the same one regardless of the table used
  2053 3C31 4C D5 37				jmp store_tables_lsb_a		; finish in the middle of the 64khz/1.79mhz branch
  2054
  2055 					EIF
  2056
  2057 				;* end of Sawtooth code...
  2058
  2059 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2060 					
  2061 				;* start of BASS16 code...
  2062
  2063 					IFT FEAT_BASS16	
  2064 3C34			do_bass16 
  2065 						IFT TRACKS>4				; stereo mode
  2066 3C34 E0 04					cpx #4					; are we in the right POKEY channels?
  2067 3C36 90 08					bcc do_bass16_a 		; if x is lower than 4, we are not
  2068 3C38 0D CB 3C					ora v_audctl2			; merge the values with the AUDCTL in memory
  2069 3C3B 8D CB 3C					sta v_audctl2			; overwrite the AUDCTL, to force 16-bit mode through Distortion 6
  2070 3C3E D0 06					bne do_bass16_b			; unconditional	
  2071 						EIF
  2072 3C40			do_bass16_a
  2073 3C40 0D 69 3C				ora v_audctl				; merge the values with the AUDCTL in memory
  2074 3C43 8D 69 3C				sta v_audctl				; overwrite the AUDCTL, to force 16-bit mode through Distortion 6
  2075 3C46			do_bass16_b 
  2076 3C46 A9 80				lda #$80 					; 16-bit pointer
  2077 3C48 9D 68 31				sta g_flag,x				; flag set in the MSB channel --actually necessary since the flag is retrieved later!
  2078 3C4B 85 D9				sta reg1					; since it is not permanent, it is good for immediate use!
  2079 3C4D 49 FF				eor #$FF 					; invert, #$80 becomes #$7F
  2080 3C4F 9D 67 31				sta g_flag-1,x				; flag set for the next channel, which will be skipped due to being in 16-bit mode now! 
  2081 3C52			do_bass16_c
  2082 						IFT FEAT_COMMAND6&&FEAT_FULL_16BIT
  2083 3C52 A5 DA					lda reg2				; Distortion and Commands
  2084 3C54 29 70					and #$70				; leave only the Commands bits
  2085 3C56 C9 60					cmp #$60				; CMD6?
  2086 3C58 D0 07					bne do_bass16_d			; skip if not CMD6
  2087 3C5A A5 DB					lda reg3				; XY parameter 
  2088 3C5C 29 0E					and #$0E				; strip away all unwanted bits, left nybble will not affect anything
  2089 3C5E 8D 62 3C					sta bass16_pointer		; PERMANENTLY change the value until a new CMD6 value is read
  2090 						EIF 
  2091 						IFT FEAT_FULL_16BIT	
  2092 3C61			do_bass16_d
  2093 3C61 A0 0A					ldy #$0A				; Distortion A
  2094 = 3C62			bass16_pointer equ *-1 
  2095 3C63 A5 D9					lda reg1				; the flag has been set, and also became the tables pointer!
  2096 3C65 4C D0 37					jmp store_tables_lsb	; continue like normal from there
  2097 							
  2098 						ELS			;* FIXMEEEE... later 
  2099 							lda #<frqtabpure_hi
  2100 							sta nr
  2101 							lda #<frqtabpure_lo
  2102 							sta trackn_bass16 	
  2103 							lda #0				
  2104 							sta trackn_audc-1,x		; update the next channel's AUDC early, it will always be volume 0, and Distortion won't matter
  2105 							lda #>PAGE_DISTORTION_A
  2106 							sta trackn_bass16+1		; this value can also be used to identify if 16-bit mode is active or not, since it will never be 0
  2107 							sta nr+1
  2108 							lda tmp
  2109 							ora #$A0
  2110 							jmp store_tables_lsb_c
  2111 						EIF
  2112 					
  2113 					EIF
  2114
  2115 				;* end of BASS16 code...
  2116
  2117 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2118 					
  2119 				;* start of the SetPokey routines...
  2120
  2121 3C68			SetPokey
  2122 3C68 A0 00			ldy #0
  2123 = 3C69			v_audctl equ *-1			; left POKEY AUDCTL is loaded as the very first thing, for all STEREOMODE variations
  2124 					IFT STEREOMODE==1		;* L1 L2 L3 L4 R1 R2 R3 R4
  2125 3C6A AD 7C 31				lda trackn_audf+0+4
  2126 3C6D AE 78 31				ldx trackn_audf+0
  2127 3C70 8D 10 D2				sta $d210
  2128 3C73 8E 00 D2				stx $d200
  2129 3C76 AD 84 31				lda trackn_audc+0+4
  2130 3C79 AE 80 31				ldx trackn_audc+0
  2131 3C7C 8D 11 D2				sta $d211
  2132 3C7F 8E 01 D2				stx $d201
  2133 3C82 AD 7D 31				lda trackn_audf+1+4
  2134 3C85 AE 79 31				ldx trackn_audf+1
  2135 3C88 8D 12 D2				sta $d212
  2136 3C8B 8E 02 D2				stx $d202
  2137 3C8E AD 85 31				lda trackn_audc+1+4
  2138 3C91 AE 81 31				ldx trackn_audc+1
  2139 3C94 8D 13 D2				sta $d213
  2140 3C97 8E 03 D2				stx $d203
  2141 3C9A AD 7E 31				lda trackn_audf+2+4
  2142 3C9D AE 7A 31				ldx trackn_audf+2
  2143 3CA0 8D 14 D2				sta $d214
  2144 3CA3 8E 04 D2				stx $d204
  2145 3CA6 AD 86 31				lda trackn_audc+2+4
  2146 3CA9 AE 82 31				ldx trackn_audc+2
  2147 3CAC 8D 15 D2				sta $d215
  2148 3CAF 8E 05 D2				stx $d205
  2149 3CB2 AD 7F 31				lda trackn_audf+3+4
  2150 3CB5 AE 7B 31				ldx trackn_audf+3
  2151 3CB8 8D 16 D2				sta $d216
  2152 3CBB 8E 06 D2				stx $d206
  2153 3CBE AD 87 31				lda trackn_audc+3+4
  2154 3CC1 AE 83 31				ldx trackn_audc+3
  2155 3CC4 8D 17 D2				sta $d217
  2156 3CC7 8E 07 D2				stx $d207
  2157 3CCA A9 00				lda #0
  2158 = 3CCB			v_audctl2 equ *-1
  2159 3CCC 8D 18 D2				sta $d218
  2160 3CCF 8C 08 D2				sty $d208
  2161 						IFT FEAT_TWO_TONE
  2162 3CD2 A9 03					lda #$03
  2163 = 3CD3			v_skctl equ *-1	
  2164 3CD4 A0 03					ldy #$03
  2165 = 3CD5			v_skctl2 equ *-1
  2166 3CD6 8C 1F D2					sty $d21f
  2167 3CD9 8D 0F D2					sta $d20f 		
  2168 						EIF
  2169 					ELI STEREOMODE==0		;* L1 L2 L3 L4
  2170 						lda trackn_audf+0
  2171 						ldx trackn_audc+0
  2172 						sta $d200
  2173 						stx $d201
  2174 						lda trackn_audf+1
  2175 						ldx trackn_audc+1
  2176 						sta $d200+2
  2177 						stx $d201+2
  2178 						lda trackn_audf+2
  2179 						ldx trackn_audc+2
  2180 						sta $d200+4
  2181 						stx $d201+4
  2182 						lda trackn_audf+3
  2183 						ldx trackn_audc+3
  2184 						sta $d200+6
  2185 						stx $d201+6
  2186 						sty $d208
  2187 						IFT FEAT_TWO_TONE
  2188 							lda #$03
  2189 				v_skctl equ *-1	
  2190 							sta $d20f
  2191 						EIF	
  2192 					ELI STEREOMODE==2		;* L1 R2 R3 L4
  2193 						lda trackn_audf+0
  2194 						ldx trackn_audc+0
  2195 						sta $d200
  2196 						stx $d201
  2197 						sta $d210
  2198 						lda trackn_audf+1
  2199 						ldx trackn_audc+1
  2200 						sta $d210+2
  2201 						stx $d211+2
  2202 						lda trackn_audf+2
  2203 						ldx trackn_audc+2
  2204 						sta $d210+4
  2205 						stx $d211+4
  2206 						sta $d200+4
  2207 						lda trackn_audf+3
  2208 						ldx trackn_audc+3
  2209 						sta $d200+6
  2210 						stx $d201+6
  2211 						sta $d210+6
  2212 						sty $d218
  2213 						sty $d208
  2214 						IFT FEAT_TWO_TONE
  2215 							lda #$03
  2216 				v_skctl equ *-1	
  2217 							sta $d20f
  2218 							sta $d21f
  2219 						EIF
  2220 					ELI STEREOMODE==3		;* L1 L2 R3 R4
  2221 						lda trackn_audf+0
  2222 						ldx trackn_audc+0
  2223 						sta $d200
  2224 						stx $d201
  2225 						lda trackn_audf+1
  2226 						ldx trackn_audc+1
  2227 						sta $d200+2
  2228 						stx $d201+2
  2229 						lda trackn_audf+2
  2230 						ldx trackn_audc+2
  2231 						sta $d210+4
  2232 						stx $d211+4
  2233 						sta $d200+4
  2234 						lda trackn_audf+3
  2235 						ldx trackn_audc+3
  2236 						sta $d210+6
  2237 						stx $d211+6
  2238 						sta $d200+6
  2239 						sty $d218
  2240 						sty $d208
  2241 						IFT FEAT_TWO_TONE
  2242 							lda #$03
  2243 				v_skctl equ *-1	
  2244 							sta $d20f
  2245 							sta $d21f
  2246 						EIF
  2247 					ELI STEREOMODE==4		;* LR1 LR2 LR3 LR4
  2248 						lda trackn_audf+0
  2249 						ldx trackn_audc+0
  2250 						sta $d200
  2251 						stx $d201
  2252 						sta $d210
  2253 						stx $d211
  2254 						lda trackn_audf+1
  2255 						ldx trackn_audc+1
  2256 						sta $d200+2
  2257 						stx $d201+2
  2258 						sta $d210+2
  2259 						stx $d211+2
  2260 						lda trackn_audf+2
  2261 						ldx trackn_audc+2
  2262 						sta $d200+4
  2263 						stx $d201+4
  2264 						sta $d210+4
  2265 						stx $d211+4
  2266 						lda trackn_audf+3
  2267 						ldx trackn_audc+3
  2268 						sta $d200+6
  2269 						stx $d201+6
  2270 						sta $d210+6
  2271 						stx $d211+6
  2272 						sty $d208
  2273 						sty $d218
  2274 						IFT FEAT_TWO_TONE
  2275 							lda #$03
  2276 				v_skctl equ *-1	
  2277 							sta $d20f
  2278 							sta $d21f
  2279 						EIF
  2280 					EIF
  2281 3CDC 60				rts
  2282 					
  2283 				;* end of SetPokey routines...
  2284 					
  2285 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2286 					
  2287 3CDD			RMTPLAYEREND
  2288 					
  2289 				;* Player ends here, what lies after is anything you want, and the extra workaround code if assembled as a 'tracker.obx' binary	
  2290
  2291 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2292
  2293 				;* Let's not forget the tables and other RMT data! 
  2294 3CDD				icl "rmtdata.a65"
Source: rmtdata.a65
     1 				;* Include with 'rmtplayr.a65'
     2 					
     3 3CDD				org TABLES	; $B000
     4 					
     5 				;* Big re-organisation in progress, nothing is definitive currently!
     6
     7 				; Each memory page are bound to a specific purpose, and must be memory alligned
     8 				; Due to the current implementation, it is imperative all tables are at the expected addresses!
     9 				; This will be refined over time, so for now this is what it is
    10
    11 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    12 B000			PAGE_DISTORTION_2	; in order: 64khz, 1.79mhz, and 16-bit (hi and lo) tables, 256 bytes 
    13 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    14 					
    15 				; Poly5 Table, 64khz, Distortion 2
    16
    17 B000			frqtabpoly5_64khz
    18 B000-B5FF> 3E 3A 37 33 +         dta $3E,$3A,$37,$33,$30,$2E,$2B,$29,$26,$24,$22,$20
    19 B00C 1F 1C 1B 19 18 16 +         dta $1F,$1C,$1B,$19,$18,$16,$15,$14,$13,$12,$10,$10
    20 B018 0F 0E 0D 0C 0B 0B +         dta $0F,$0E,$0D,$0C,$0B,$0B,$0A,$09,$09,$08,$08,$07
    21 B024 07 06 06 06 05 05 +         dta $07,$06,$06,$06,$05,$05,$05,$04,$04,$04,$03,$03
    22 B030 03 03 02 02 02 02 +         dta $03,$03,$02,$02,$02,$02,$02,$02,$01,$01,$01,$01
    23 B03C 00 00 00 00		        dta $00,$00,$00,$00
    24 				        
    25 				; Poly5 Table, 1.79mhz, Distortion 2
    26
    27 B040			frqtabpoly5_179mhz
    28 B040 D7 CA BE B3 A9 9F +         dta $D7,$CA,$BE,$B3,$A9,$9F,$96,$8D,$85,$7E,$77,$70
    29 B04C 69 63 5E 58 53 4E +         dta $69,$63,$5E,$58,$53,$4E,$49,$45,$41,$3D,$39,$36
    30 B058 32 2F 2D 2A 27 25 +         dta $32,$2F,$2D,$2A,$27,$25,$23,$20,$1E,$1D,$1A,$19
    31 B064 17 16 14 13 12 11 +         dta $17,$16,$14,$13,$12,$11,$0F,$0E,$0D,$0C,$0B,$0A
    32 B070 0A 09 08 07 07 06 +         dta $0A,$09,$08,$07,$07,$06,$06,$05,$05,$04,$04,$03
    33 B07C 03 02 02 02		        dta $03,$02,$02,$02 
    34 					
    35 				; Poly5 Table, 16-bit, Distortion 2
    36
    37 B080			frqtabpoly5_16bit
    38 B080 62 03 31 03 03 03 + 	dta a($0362,$0331,$0303,$02D7,$02AE,$0287,$0262,$0240,$021F,$0200,$01E3,$01C7)
    39 B098 AD 01 95 01 7E 01 + 	dta a($01AD,$0195,$017E,$0168,$0153,$0140,$012E,$011C,$010C,$00FD,$00EE,$00E0)
    40 B0B0 D3 00 C7 00 BB 00 + 	dta a($00D3,$00C7,$00BB,$00B1,$00A6,$009D,$0093,$008B,$0082,$007B,$0073,$006D)
    41 B0C8 66 00 60 00 5A 00 + 	dta a($0066,$0060,$005A,$0055,$0050,$004B,$0046,$0042,$003E,$003A,$0036,$0033)
    42 B0E0 30 00 2C 00 2A 00 + 	dta a($0030,$002C,$002A,$0027,$0024,$0022,$0020,$001D,$001B,$0019,$0017,$0016)
    43 B0F8 14 00 13 00 11 00 + 	dta a($0014,$0013,$0011,$0010)
    44
    45 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    46 B100			PAGE_DISTORTION_4	; in order: 64khz, 1.79mhz, and 16-bit (hi and lo) tables, 256 bytes 
    47 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    48 					
    49 				; 64khz, Distortion 4
    50
    51 B100			frqtabdist4_64khz
    52 B100 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    53 B10C 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    54 B118 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    55 B124 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    56 B130 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    57 B13C 00 00 00 00		        dta $00,$00,$00,$00
    58 				        
    59 				; 1.79mhz, Distortion 4
    60
    61 B140			frqtabdist4_179mhz
    62 B140 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    63 B14C 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    64 B158 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    65 B164 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    66 B170 00 00 00 00 00 00 +         dta $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    67 B17C 00 00 00 00		        dta $00,$00,$00,$00 
    68 					
    69 				; 16-bit, Distortion 4
    70
    71 B180			frqtabdist4_16bit
    72 B180 00 00 00 00 00 00 + 	dta a($0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000)
    73 B198 00 00 00 00 00 00 + 	dta a($0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000)
    74 B1B0 00 00 00 00 00 00 + 	dta a($0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000)
    75 B1C8 00 00 00 00 00 00 + 	dta a($0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000)
    76 B1E0 00 00 00 00 00 00 + 	dta a($0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000)
    77 B1F8 00 00 00 00 00 00 + 	dta a($0000,$0000,$0000,$0000) 
    78
    79 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    80 B200			PAGE_DISTORTION_A	; in order: 64khz, 1.79mhz, and 16-bit (hi and lo) tables, 256 bytes 
    81 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    82 					
    83 				; Pure Table, 64khz, Distortion A
    84
    85 B200			frqtabpure_64khz
    86 B200 F1 E3 D6 CA BF B4 + 	dta $F1,$E3,$D6,$CA,$BF,$B4,$AA,$A0,$97,$8F,$87,$7F
    87 B20C 78 71 6B 65 5F 5A + 	dta $78,$71,$6B,$65,$5F,$5A,$54,$50,$4B,$47,$43,$3F
    88 B218 3B 38 35 32 2F 2C + 	dta $3B,$38,$35,$32,$2F,$2C,$2A,$27,$25,$23,$21,$1F
    89 B224 1D 1C 1A 18 17 16 + 	dta $1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    90 B230 0E 0D 0C 0C 0B 0A + 	dta $0E,$0D,$0C,$0C,$0B,$0A,$0A,$09,$09,$08,$07,$07
    91 B23C 07 06 06 05			dta $07,$06,$06,$05
    92
    93 				; Pure Table, 1.79mhz, Distortion A
    94
    95 B240			frqtabpure_179mhz
    96 B240 CF C4 B8 AE A4 9A +         dta $CF,$C4,$B8,$AE,$A4,$9A,$92,$89,$81,$7A,$73,$6C	; Octave 8
    97 B24C 66 60 5A 55 50 4B +         dta $66,$60,$5A,$55,$50,$4B,$47,$43,$3F,$3B,$37,$34
    98 B258 31 2E 2B 28 26 24 +         dta $31,$2E,$2B,$28,$26,$24,$21,$1F,$1D,$1B,$1A,$18
    99 B264 17 16 14 13 12 11 +         dta $17,$16,$14,$13,$12,$11,$0F,$0E,$0D,$0C,$0B,$0A	; copied from Poly5 1.79mhz, mostly
   100 B270 0A 09 08 07 07 06 +         dta $0A,$09,$08,$07,$07,$06,$06,$05,$05,$04,$04,$03
   101 B27C 03 02 01 00		        dta $03,$02,$01,$00 
   102
   103 				; Pure Table, 16-bit, Distortion A
   104
   105 B280			frqtabpure_16bit
   106 B280 B0 69 C1 63 27 5E + 	dta a($69B0,$63C1,$5E27,$58DE,$53E1,$4F2B,$4AB9,$4687,$4291,$3ED5,$3B4D,$37F9)
   107 B298 D4 34 DD 31 10 2F + 	dta a($34D4,$31DD,$2F10,$2C6B,$29ED,$2792,$2559,$2340,$2145,$1F67,$1DA3,$1BF9)
   108 B2B0 67 1A EB 18 85 17 + 	dta a($1A67,$18EB,$1785,$1632,$14F3,$13C6,$12A9,$119D,$109F,$0FB0,$0ECE,$0DF9)
   109 B2C8 30 0D 72 0C BF 0B + 	dta a($0D30,$0C72,$0BBF,$0B16,$0A76,$09DF,$0951,$08CB,$084C,$07D4,$0764,$06F9)
   110 B2E0 94 06 35 06 DC 05 + 	dta a($0694,$0635,$05DC,$0587,$0537,$04EC,$04A5,$0462,$0423,$03E7,$03AE,$0379)
   111 B2F8 47 03 17 03 EA 02 + 	dta a($0347,$0317,$02EA,$02C0)
   112
   113 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   114 B300			PAGE_DISTORTION_C	; in order: 64khz, 1.79mhz, and 16-bit (hi and lo) tables, 256 bytes 
   115 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   116
   117 				; Buzzy Bass Table, 64khz, Distortion C
   118
   119 B300			frqtabbuzzy_64khz
   120 B300 7F 79 73 6C 66 60 +         dta $7F,$79,$73,$6C,$66,$60,$5A,$55,$F2,$E6,$D7,$CB
   121 B30C BF B6 AA A1 98 8F +         dta $BF,$B6,$AA,$A1,$98,$8F,$89,$80,$7A,$71,$6B,$65
   122 B318 5F 5C 56 50 4D 47 +         dta $5F,$5C,$56,$50,$4D,$47,$44,$41,$3E,$38,$35,$32
   123 B324 2F 2F 29 29 26 23 +         dta $2F,$2F,$29,$29,$26,$23,$20,$20,$20,$1A,$1A,$17
   124 B330 17 17 14 14 11 11 +         dta $17,$17,$14,$14,$11,$11,$11,$11,$11,$0B,$0B,$0B
   125 B33C 0B 0B 0B 08		        dta $0B,$0B,$0B,$08
   126 				        
   127 				; Poly4 Buzzy Table, 1.79mhz, Distortion C
   128
   129 B340			frqtabbuzzy_179mhz
   130 B340 6D 66 61 5A 55 F8 +         dta $6D,$66,$61,$5A,$55,$F8,$E9,$E0,$D1,$C5,$B9,$AD	; Octave 6
   131 B34C A4 9B 95 89 80 7A +         dta $A4,$9B,$95,$89,$80,$7A,$71,$6E,$68,$62,$5C,$53
   132 B358 50 4D 4A 44 3E 3B +         dta $50,$4D,$4A,$44,$3E,$3B,$35,$35,$32,$2F,$2C,$26
   133 B364 26 23 23 20 1D 1D +         dta $26,$23,$23,$20,$1D,$1D,$1D,$17,$17,$14,$14,$11
   134 B370 0A 09 08 07 07 06 +         dta $0A,$09,$08,$07,$07,$06,$06,$05,$05,$04,$04,$03	; copied from Poly5 1.79mhz, mostly
   135 B37C 03 02 01 00		        dta $03,$02,$01,$00 
   136
   137 				; Poly4 Buzzy Table, 16-bit, Distortion C
   138
   139 B380			frqtabbuzzy_16bit
   140 B380 41 2A E3 27 A3 25 + 	dta a($2A41,$27E3,$25A3,$2387,$2189,$1FA6,$1DE1,$1C31,$1A9C,$191F,$17B7,$165E)
   141 B398 1D 15 EE 13 CE 12 + 	dta a($151D,$13EE,$12CE,$11C0,$10C1,$0FD1,$0EED,$0E15,$0D4C,$0C8C,$0BD8,$0B2D)
   142 B3B0 8B 0A F2 09 65 09 + 	dta a($0A8B,$09F2,$0965,$08DE,$085D,$07E5,$0773,$0707,$06A1,$0641,$05E7,$0593)
   143 B3C8 42 05 F7 04 AF 04 + 	dta a($0542,$04F7,$04AF,$046A,$042B,$03EF,$03B6,$0380,$034D,$031D,$02F0,$02C6)
   144 B3E0 9F 02 78 02 54 02 + 	dta a($029F,$0278,$0254,$0230,$0212,$01F4,$01D6,$01BE,$01A3,$018B,$0176,$015E)
   145 B3F8 4C 01 37 01 28 01 + 	dta a($014C,$0137,$0128,$0113)
   146
   147 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   148 B400			PAGE_DISTORTION_E	; in order: 64khz, 1.79mhz, and 16-bit (hi and lo) tables, 256 bytes
   149 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   150
   151 				; Gritty Bass Table, 64khz, Distortion C
   152
   153 B400			frqtabgritty_64khz 
   154 B400 FF F3 E4 D8 CD C0 +         dta $FF,$F3,$E4,$D8,$CD,$C0,$B5,$AB,$A2,$99,$91,$88 
   155 B40C 7F 79 73 6C 66 60 +         dta $7F,$79,$73,$6C,$66,$60,$5A,$55,$51,$4C,$48,$43
   156 B418 3F 3C 39 34 33 30 +         dta $3F,$3C,$39,$34,$33,$30,$2D,$2A,$28,$25,$24,$21
   157 B424 1F 1E 1C 50 19 47 +         dta $1F,$1E,$1C,$50,$19,$47,$16,$15,$3E,$12,$35,$10
   158 B430 0F 0F 0D 0D 0C 23 +         dta $0F,$0F,$0D,$0D,$0C,$23,$0A,$0A,$0A,$1A,$1A,$07
   159 B43C 07 07 06 06		        dta $07,$07,$06,$06
   160
   161 				; Poly4 Gritty Table, 1.79mhz, Distortion C
   162
   163 B440			frqtabgritty_179mhz
   164 B440 DE D0 C6 BB AF A5 +         dta $DE,$D0,$C6,$BB,$AF,$A5,$9A,$93,$8A,$82,$7B,$73	; Octave 5
   165 B44C 6D 66 61 5A 55 4F +         dta $6D,$66,$61,$5A,$55,$4F,$4B,$48,$43,$3F,$3C,$37
   166 B458 34 31 2D 2B 28 27 +         dta $34,$31,$2D,$2B,$28,$27,$25,$22,$21,$1E,$1C,$19
   167 B464 18 16 16 13 12 12 +         dta $18,$16,$16,$13,$12,$12,$0F,$0F,$0D,$0D,$0C,$0A
   168 B470 0A 09 09 07 07 07 +         dta $0A,$09,$09,$07,$07,$07,$07,$04,$04,$04,$04,$03
   169 B47C 03 02 01 00			dta $03,$02,$01,$00
   170
   171 				; Poly4 Gritty Table, 16-bit, Distortion C
   172
   173 B480			frqtabgritty_16bit
   174 B480 11 0E 47 0D 87 0C + 	dta a($0E11,$0D47,$0C87,$0BD3,$0B29,$0A89,$09F1,$0961,$08DA,$085B,$07E3,$0771)
   175 B498 05 07 A0 06 40 06 + 	dta a($0705,$06A0,$0640,$05E6,$0591,$0541,$04F5,$04AD,$0469,$042A,$03EE,$03B5)
   176 B4B0 7F 03 4C 03 1C 03 + 	dta a($037F,$034C,$031C,$02EF,$02C5,$029D,$0277,$0253,$0231,$0211,$01F3,$01D7)
   177 B4C8 BC 01 A4 01 8A 01 + 	dta a($01BC,$01A4,$018A,$0174,$015F,$014B,$0138,$0126,$0115,$0105,$00F6,$00E8)
   178 B4E0 DB 00 CD 00 C3 00 + 	dta a($00DB,$00CD,$00C3,$00B8,$00AC,$00A2,$0097,$0090,$0087,$007F,$0078,$0070)
   179 B4F8 6A 00 63 00 5E 00 + 	dta a($006A,$0063,$005E,$0057)
   180
   181 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   182 B500			PAGE_EXTRA_0	; in order: Sawtooth tables, and 15khz tables for Distortion A and C, 256 bytes 
   183 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   184
   185 				; Croissant Sawtooth, use on Channel 1 or 3, must be muted on channel 3
   186
   187 B500			frqtabsawtooth_ch1
   188 B500 E4 DE D7 D1 CB C5 + 	dta $E4,$DE,$D7,$D1,$CB,$C5,$BF,$BA,$B4,$AF,$AA,$A5
   189 B50C A0 9B 97 92 8E 8A + 	dta $A0,$9B,$97,$92,$8E,$8A,$86,$82,$7E,$7A,$77,$73
   190 B518 70 6D 69 66 63 60 + 	dta $70,$6D,$69,$66,$63,$60,$5D,$81,$58,$7A,$76,$50
   191 B524 4E 6C 69 47 45 43 + 	dta $4E,$6C,$69,$47,$45,$43,$5D,$5A,$57,$3B,$52,$62
   192 B530 4D 34 68 31 62 42 + 	dta $4D,$34,$68,$31,$62,$42,$5C,$2B,$6A,$67,$6C,$58
   193 B53C 35 4A 32 4E			dta $35,$4A,$32,$4E
   194
   195 				; Croissant Sawtooth, use on Channel 1 or 3, must be muted on channel 3
   196
   197 B540			frqtabsawtooth_ch3
   198 B540 E5 DF D8 D2 CC C6 + 	dta $E5,$DF,$D8,$D2,$CC,$C6,$C0,$BB,$B5,$B0,$AB,$A6
   199 B54C A1 9C 98 93 8F 8B + 	dta $A1,$9C,$98,$93,$8F,$8B,$87,$83,$7F,$7B,$78,$74
   200 B558 71 6E 6A 67 64 61 + 	dta $71,$6E,$6A,$67,$64,$61,$5E,$83,$59,$7C,$78,$51
   201 B564 4F 6E 6B 48 46 44 + 	dta $4F,$6E,$6B,$48,$46,$44,$5F,$5C,$59,$3C,$54,$65
   202 B570 4F 35 6C 32 66 44 + 	dta $4F,$35,$6C,$32,$66,$44,$60,$2C,$70,$6D,$73,$5D
   203 B57C 37 4E 34 53			dta $37,$4E,$34,$53
   204
   205 				; Pure Table, 15khz, Distortion A
   206
   207 B580			frqtabpure_15khz
   208 B580 ED DF D2 C7 BB B1 +         dta $ED,$DF,$D2,$C7,$BB,$B1,$A7,$9D,$95,$8C,$84,$7D
   209 B58C 76 6F 69 63 5D 58 +         dta $76,$6F,$69,$63,$5D,$58,$53,$4E,$4A,$45,$42,$3E
   210 B598 3A 37 34 31 2E 2B +         dta $3A,$37,$34,$31,$2E,$2B,$29,$27,$24,$22,$20,$1E
   211 B5A4 1D 1B 1A 18 17 15 +         dta $1D,$1B,$1A,$18,$17,$15,$14,$13,$12,$11,$10,$0F
   212 B5B0 0E 0D 0C 0C 0B 0A +         dta $0E,$0D,$0C,$0C,$0B,$0A,$0A,$09,$08,$08,$07,$07
   213 B5BC 06 06 06 05		        dta $06,$06,$06,$05
   214
   215 				; Buzzy Bass Table, 15khz, Distortion C
   216
   217 B5C0			frqtabbuzzy_15khz
   218 B5C0 BC B2 A8 9E 96 8D +         dta $BC,$B2,$A8,$9E,$96,$8D,$85,$7E,$76,$70,$6A,$64
   219 B5CC 5F 58 53 4E 4B 46 +         dta $5F,$58,$53,$4E,$4B,$46,$42,$3E,$3A,$37,$34,$32
   220 B5D8 2E 2B 29 26 25 23 +         dta $2E,$2B,$29,$26,$25,$23,$21,$1F,$1C,$1B,$1A,$19
   221 B5E4 17 16 15 14 12 11 +         dta $17,$16,$15,$14,$12,$11,$10,$0F,$0D,$0D,$0C,$0C
   222 B5F0 0B 0A 0A 0A 08 08 +         dta $0B,$0A,$0A,$0A,$08,$08,$07,$07,$06,$06,$06,$05
   223 B5FC 05 05 05 03		        dta $05,$05,$05,$03
   224
   225 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   226 B600			PAGE_EXTRA_1	; Unused
   227 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   228
   229 					IFT FEAT_TABLE_MANUAL
   230 					org TABLES+$500
   231
   232 				; Clarinet Tone Table, Reverse-16 lo, Distortion C
   233
   234 				clarinet_lo
   235 					dta $E2,$D6,$06,$63,$FC,$95,$5B,$30,$41,$70,$BD,$FB
   236 					dta $75,$EF,$96,$5B,$F3,$E5,$9B,$AB,$9D,$BC,$DB,$FA
   237 					dta $19,$74,$CF,$1B,$76,$D1,$59,$B4,$4B,$D3,$6A,$F2
   238 					dta $89,$4D,$E4,$7B,$3F,$03,$9A,$5E,$22,$E6,$AA,$7D
   239 					dta $41,$14,$E7,$BA,$9C,$7E,$42,$24,$06,$F2,$D9,$BB
   240 					dta $9D,$8E,$70,$61      
   241
   242 				; Clarinet Harmonic Table, Reverse-16 hi, Distortion A
   243
   244 				clarinet_hi
   245 					dta $34,$31,$2F,$2C,$29,$27,$25,$23,$21,$1F,$1D,$1B
   246 					dta $1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D
   247 					dta $0D,$0C,$0B,$0B,$0A,$09,$09,$08,$08,$07,$07,$06
   248 					dta $06,$06,$05,$05,$05,$05,$04,$04,$04,$03,$03,$03
   249 					dta $03,$03,$02,$02,$02,$02,$02,$02,$02,$01,$01,$01
   250 					dta $01,$01,$01,$01
   251 					EIF
   252
   253 				;---------------------------------------------------------------------------------------------------------------------------------------------;
   254
   255 				; and that's all... I guess 
   256
  2295 					
  2296 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2297 					
  2298 				;* The workaround code is mandatory in order to avoid many things breaking in RMT!
  2299 					IFT FEAT_IS_TRACKER
  2300 B600				icl "rmtextra.a65" 
Source: rmtextra.a65
     1 				; include with 'rmtplayr.a65'
     2
     3 				;---------------------------------------------------------------------------------------------------------------------------------------------;
     4
     5 				;* start of GetInstrumentY2 code...
     6
     7 B600			        org $3D00
     8 3D00			GetInstrumentY2			; 6502_jsr() was called by RMT with values in memory...
     9 3D00-3D0E> 9D 60 30	        sta trackn_note,x	; store as the new note value
    10 3D03 98			        tya 			; transfer the index y to the accumulator
    11 3D04 0A			        asl @ 			; shift the accumulator left 1 bit, essentially multiplying the value by 2
    12 3D05 9D B8 30		        sta trackn_instrx2,x	; store in memory, positive value means new instrument to intialise
    13 3D08 30 04		        bmi SkipInstrumentY2	; if negative, there is no new instrument to initialise
    14 3D0A A8			        tay 			; transfer the accumulator back to index y for the next step
    15 3D0B 4C 89 35		        jmp SetUpInstrumentY2	; new instrument to initialise with the values in memory. The subroutine will end with a rts, meaning the instrument has been set up and ready to use
    16 3D0E			SkipInstrumentY2       
    17 3D0E 60			        rts 			; 6502_jsr() ends upon hitting a RTS, the subroutine finished early, no new instrument was set up
    18
    19 				;* end of GetInstrumentY2 code...
    20
    21 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    22
    23 				;* start of SetInstrumentVolume code...
    24
    25 3D0F			        org $3E00
    26 3E00			SetInstrumentVolume 		; 6502_jsr() was called by RMT with values in memory...
    27 3E00-3E07> 0A 0A 0A 0A	        :4 asl @ 		; shift the accumulator left 1 bit, 4 times, essentially multiplying the value by 16
    28 3E04 9D 68 30		        sta trackn_volume,x	; store the new value in memory, which will be used for the volume lookup table during playback
    29 3E07 60			        rts 			; 6502_jsr() ends upon hitting a RTS, the volume value was updated
    30 				        
    31 				;* end of SetInstrumentVolume code...
    32
    33 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    34
    35 				;* start of StopInstrument code...
    36
    37 3E08			        org $3E80
    38 3E80			StopInstrument                  ; 6502_jsr() was called by RMT with values in memory...
    39 3E80-3EFC> A9 00		        lda #0 			; zeroes will be written to the current channel's variables to stop it playing...
    40 3E82 9D 68 30		        sta trackn_volume,x
    41 3E85 9D C8 30		        sta trackn_instrhb,x
    42 3E88 9D C0 30		        sta trackn_instrdb,x
    43 3E8B 9D 80 31		        sta trackn_audc,x
    44 				;	sta trackn_audf,x	; reset the channel's AUDF (not actually used)...
    45 3E8E 60			        rts 			; 6502_jsr() ends upon hitting a RTS, values have been overwritten
    46 				        
    47 				;* end of StopInstrument code...
    48 				        
    49 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    50 				        
    51 				;* Improvements: many more values could benefit from writing zeroes into them, preventing the leftover data to stay in memory and conflict with a bunch of things...
    52 				;* Even better, an alternative version of rmt_silence could be added here as well, specifically for the purpose of properly reseting the driver when used in the tracker itself...
    53
    54 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    55
    56 				;* start of plaintext data... this is totally useless, and purely cosmetic. Use only for RMT version 1.32.06 and above...
    57
    58 3E8F 00			       dta $00			; allign memory for the DriverVersion label... 
    59 				;	org $????		; could be set anywhere... not yet decided...
    60 3E90			DriverVersion
    61 3E90 50 61 74 63 68 20 + 	dta c"Patch 16-3.4 by VinsCool"
    62 3EA8 00				dta $00			; allign memory, and text terminator
    63 3EA9 48 65 6C 6C 6F 20 + 	dta c"Hello Bitches... :3 Please don't mind me I am testing bytes overflow... is it dead?"
    64 3EFC 00				dta $00			; allign memory, and easter egg... hehehehe ;)
    65 					
    66 				;* end of plaintext data...
    67
    68 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    69
    70 				;* RMT8 HEADER and some other placeholder stuff? This is currently not yet understood... 
    71 				;* Whatever this is used for exactly... It is MANDATORY to make the driver work at all in RMT!
    72 				;* If this data is missing or damaged, the driver will behave incorrectly, leading to garbage data being played, or even a crash!
    73 				;* since I have no full understanding of this part, it's included directly as data instead of code...
    74
    75 3EFD				org $3F00 
    76 3F00			ExtraRMTStuff
    77 3F00-3F9B> 52 4D 54 38 + 	dta $52,$4D,$54,$38,$40,$40,$01,$00,$10,$3F,$00,$00,$00,$00,$90,$3F
    78 3F10 00 40 00 41 00 42 + 	dta $00,$40,$00,$41,$00,$42,$00,$43,$00,$44,$00,$45,$00,$46,$00,$47
    79 3F20 00 48 00 49 00 4A + 	dta $00,$48,$00,$49,$00,$4A,$00,$4B,$00,$4C,$00,$4D,$00,$4E,$00,$4F
    80 3F30 00 50 00 51 00 52 + 	dta $00,$50,$00,$51,$00,$52,$00,$53,$00,$54,$00,$55,$00,$56,$00,$57
    81 3F40 00 58 00 59 00 5A + 	dta $00,$58,$00,$59,$00,$5A,$00,$5B,$00,$5C,$00,$5D,$00,$5E,$00,$5F
    82 3F50 00 60 00 61 00 62 + 	dta $00,$60,$00,$61,$00,$62,$00,$63,$00,$64,$00,$65,$00,$66,$00,$67
    83 3F60 00 68 00 69 00 6A + 	dta $00,$68,$00,$69,$00,$6A,$00,$6B,$00,$6C,$00,$6D,$00,$6E,$00,$6F
    84 3F70 00 70 00 71 00 72 + 	dta $00,$70,$00,$71,$00,$72,$00,$73,$00,$74,$00,$75,$00,$76,$00,$77
    85 3F80 00 78 00 79 00 7A + 	dta $00,$78,$00,$79,$00,$7A,$00,$7B,$00,$7C,$00,$7D,$00,$7E,$00,$7F
    86 3F90 FF FF FF FF FF FF + 	dta $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FE,$00,$90,$3F
    87 					
    88 				;* end of extra RMT stuff, whatever this is really...
    89
    90 				;---------------------------------------------------------------------------------------------------------------------------------------------;
    91
    92 				;* and that's all... nothing else needed here... yet... ;D 
    93
  2301 					EIF
  2302
  2303 				;---------------------------------------------------------------------------------------------------------------------------------------------;
  2304
  2305 				;* And that's all folks :D
  2306
